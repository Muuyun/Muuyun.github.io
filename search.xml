<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux帮助命令和crontab]]></title>
    <url>%2F2019%2F02%2F21%2Flinux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[内建命令与外部命令可以用type来区分命令是内建的还是外部的1type + 命令 内建命令是写在bash源码的builtins里面的 外部命令通常放在/bin，/user/bin,/sbin,/usr/sbin等等 crontab语法用于设置周期性被执行的指令。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。 crontab 的格式:12345678# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 12$ crontab -e 表示为当前用户添加计划任务$ sudo crontab -e 表示为root用户添加计划任务]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 反射（Reflection）]]></title>
    <url>%2F2019%2F02%2F21%2Fc%20sharp%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射（Reflection）的用途反射（Reflection）有下列用途： 它允许在运行时查看特性（attribute）信息。 它允许审查集合中的各种类型，以及实例化这些类型。 它允许延迟绑定的方法和属性（property）。 它允许在运行时创建新类型，然后使用这些类型执行一些任务。 查看元数据使用反射（Reflection）可以查看特性（attribute）信息。 System.Reflection 类的 MemberInfo 对象需要被初始化，用于发现与类相关的特性（attribute）。为了做到这点，您可以定义目标类的一个对象，如下：1System.Reflection.MemberInfo info = typeof(MyClass); 下面的程序演示了这点：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;[AttributeUsage(AttributeTargets.All)]public class HelpAttribute : System.Attribute&#123; public readonly string Url; public string Topic // Topic 是一个命名（named）参数 &#123; get &#123; return topic; &#125; set &#123; topic = value; &#125; &#125; public HelpAttribute(string url) // url 是一个定位（positional）参数 &#123; this.Url = url; &#125; private string topic;&#125;[HelpAttribute(&quot;Information on the class MyClass&quot;)]class MyClass&#123;&#125;namespace AttributeAppl&#123; class Program &#123; static void Main(string[] args) &#123; System.Reflection.MemberInfo info = typeof(MyClass); object[] attributes = info.GetCustomAttributes(true); for (int i = 0; i &lt; attributes.Length; i++) &#123; System.Console.WriteLine(attributes[i]); &#125; Console.ReadKey(); &#125; &#125;&#125; 当上面的代码被编译和执行时，它会显示附加到类 MyClass 上的自定义特性：1HelpAttribute]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 特性（Attribute）]]></title>
    <url>%2F2019%2F02%2F21%2Fc%20sharp%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。 .Net 框架提供了两种类型的特性：预定义特性和自定义特性。 预定义特性（Attribute）.Net 框架提供了三种预定义特性： AttributeUsage Conditional Obsolete 创建自定义特性（Attribute）创建并使用自定义特性包含四个步骤： 声明自定义特性 构建自定义特性 在目标程序元素上应用自定义特性 通过反射访问特性 声明自定义特性一个新的自定义特性应派生自 System.Attribute 类。例如： 123456789// 一个自定义特性 BugFix 被赋给类及其成员[AttributeUsage(AttributeTargets.Class |AttributeTargets.Constructor |AttributeTargets.Field |AttributeTargets.Method |AttributeTargets.Property,AllowMultiple = true)]public class DeBugInfo : System.Attribute 在上面的代码中，我们已经声明了一个名为 DeBugInfo 的自定义特性。 构建自定义特性让我们构建一个名为 DeBugInfo 的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息： bug 的代码编号 辨认该 bug 的开发人员名字 最后一次审查该代码的日期 一个存储了开发人员标记的字符串消息 我们的 DeBugInfo 类将带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（property）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，消息将是一个可选的命名（named）参数。 每个特性必须至少有一个构造函数。必需的定位（ positional）参数应通过构造函数传递。下面的代码演示了 DeBugInfo 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 一个自定义特性 BugFix 被赋给类及其成员[AttributeUsage(AttributeTargets.Class |AttributeTargets.Constructor |AttributeTargets.Field |AttributeTargets.Method |AttributeTargets.Property,AllowMultiple = true)]public class DeBugInfo : System.Attribute&#123; private int bugNo; private string developer; private string lastReview; public string message; public DeBugInfo(int bg, string dev, string d) &#123; this.bugNo = bg; this.developer = dev; this.lastReview = d; &#125; public int BugNo &#123; get &#123; return bugNo; &#125; &#125; public string Developer &#123; get &#123; return developer; &#125; &#125; public string LastReview &#123; get &#123; return lastReview; &#125; &#125; public string Message &#123; get &#123; return message; &#125; set &#123; message = value; &#125; &#125;&#125; 应用自定义特性通过把特性放置在紧接着它的目标之前，来应用该特性：1234567891011121314151617181920212223242526[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)][DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]class Rectangle&#123; // 成员变量 protected double length; protected double width; public Rectangle(double l, double w) &#123; length = l; width = w; &#125; [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;, Message = &quot;Return type mismatch&quot;)] public double GetArea() &#123; return length * width; &#125; [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)] public void Display() &#123; Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length); Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width); Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea()); &#125;&#125;]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牧云集-1]]></title>
    <url>%2F2019%2F02%2F21%2F%E7%89%A7%E4%BA%91%E9%9B%86-1%2F</url>
    <content type="text"><![CDATA[故事1 新郎，特地和司仪要了话筒，说了一段话，他说他父母婚姻不幸，心里那个自己，从来没有长大过。 从来我不是不爱你，不是一次次想要推开你。不是心有不忿意难平。这世间，离别太多。 太美好的你，怕握不住。 嗯，那个戒指，他配了项链挂在胸口。忽然明白，为什么十年，依旧是他们两个。 或许女孩子从来不卑微，她知道命中注定就是他。 嗯，我一直看见的婚礼都是新娘哭，新郎笑。 今天第一次看见新郎哭得双肩耸动，新娘笑着安慰，帮他抹泪。 很甜！ 故事二 高中时一个同学沉迷网络 时常半夜翻墙出校上网 一日他照例翻墙 翻到一半就拔足狂奔而归 面色古怪，问之不语 从此认真读书，不再上网 学校盛传他见鬼了 后来他考上名校，我们问起这事 他沉默良久，说 “那天父亲来送生活费 舍不得住旅馆，在墙下坐了一夜”]]></content>
      <categories>
        <category>洛书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python-1]]></title>
    <url>%2F2019%2F02%2F16%2Fpython1%2F</url>
    <content type="text"><![CDATA[输入与输出12name = input(&apos;please enter your name: &apos;)print(&apos;hello,&apos;, name) python基础 Python允许用r’’表示’’内部的字符串默认不转义 1234print(&apos;\\\t\\&apos;)\ \print(r&apos;\\\t\\&apos;)\\\t\\ 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容, ...是提示符，不是代码的一部分 12print(r&apos;&apos;&apos;hello,world&apos;&apos;&apos;) 一个布尔值只有True、False两种值,布尔值可以用and、or和not运算。 用全部大写的变量名表示常量只是一个习惯上的用法 , eg: PI 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 129 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数：1210 // 33 Python的整数没有大小限制，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 字符编码 美国ASCII编码 中国GB2312编码 Unicode统一编码 -&gt; UTF-8编码(可变长编码) 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器 Python的字符串对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：12345678&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos; 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示：1x = b&apos;ABC&apos; 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：12345678&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：1234&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)&apos;ABC&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)&apos;中文&apos; 如果bytes中包含无法解码的字节，decode()方法会报错：1234&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;)Traceback (most recent call last): ...UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte 如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节：12&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)&apos;中&apos; 要计算str包含多少个字符，可以用len()函数：1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：123456&gt;&gt;&gt; len(b&apos;ABC&apos;)3&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)6&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))6 格式化在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：1234&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos; 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm-basics]]></title>
    <url>%2F2019%2F02%2F16%2Fpycharm%2F</url>
    <content type="text"><![CDATA[常用的默认快捷键： 调试栏的几个重要的按钮作用： Resume Program：断点调试后，点击按钮，继续执行程序； Step Over ：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和Step Into效果一样的（简而言之，越过子函数，但子函数会执行）； Step Into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）； Step Out ： 当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。 PythonPython报错TypeError: ‘&lt;’ not supported between instances of ‘str’ and ‘int’input()返回的数据类型是str，不能直接和整数进行比较，必须先把str换成整数，使用int()方法1231 n = int(input(&quot;Input a number:&quot;))2 if n&gt;=100:print(int(n)/10)3 else:print(int(n)*10)]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件系统操作与磁盘管理]]></title>
    <url>%2F2019%2F02%2F16%2Flinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[查看磁盘和目录的容量 使用df命令查看磁盘的容量12$ df$ df -h 使用du命令查看目录的容量 1234# 默认同样以 块 的大小展示$ du# 加上-h参数，以更易读的方式展示$ du -h -d 参数指定查看目录的深度1234# 只查看1级目录的信息$ du -h -d 0 ~# 查看2级$ du -h -d 1 ~ 常用参数123du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。du -a #同--all 显示目录中所有文件的大小。du -s #同--summarize 仅显示总计，只列出最后加总的值。 创建虚拟磁盘 用dd命令从标准输入读入用户的输入到标准输出或者一个文件中： 12345# 输出到文件$ dd of=test bs=10 count=1# 输出到标准输出$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1# 注:在打完了这个命令后，继续在终端打字，作为你的输入 bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。 将输出的英文字符转换为大写再写入文件：1$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase 使用 dd 命令创建虚拟镜像文件 从/dev/zero设备创建一个容量为 256M 的空文件：12$ dd if=/dev/zero of=virtual.img bs=1M count=256$ du -h virtual.img 使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像） $ sudo mkfs.ext4 virtual.img 使用 mount 命令挂载磁盘到目录树 mount命令的一般格式如下： 1mount [options] [source] [directory] 一些常用操作： 1mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-basics]]></title>
    <url>%2F2019%2F02%2F16%2Flinux%2F</url>
    <content type="text"><![CDATA[Linux的几个优点： 免费 很多软件原生是在Linux下运行的，庞大的社区支持，生态环境好。 开源，可被定制，开放，多用户的网络操作系统。 相对安全稳定 ## bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 作者：Java3y链接：https://www.jianshu.com/p/a182a0be4b8a]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux压缩解压工具]]></title>
    <url>%2F2019%2F02%2F15%2Flinux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[压缩文件linux常见格式：.zip,.rar,.7z,.tar,.gz,.xz,.bz2,.tar.gz,.tar.xz,tar.bz2,.tar.7z zip压缩打包程序使用zip打包文件夹1234$ cd /home/shiyanlou$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop$ du -h shiyanlou.zip$ file shiyanlou.zip -r 参数表示递归打包包含子目录的全部内容， -q 参数表示为安静模式，即不向屏幕输出信息， -o，表示输出文件，需在其后紧跟打包输出文件名。 du ,命令查看打包后文件的大小 设置压缩级别为9和1（9最大，1最小），重新打包：12$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip -[1-9] 表示压缩级别，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意：这里只能使用绝对路径，否则不起作用。 创建加密 zip 包使用 -e 参数可以创建加密压缩包：1$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop 如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题,需要加上 -l参数将LF 转换为 CR+LF1$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop 使用 unzip 命令解压缩 zip 文件将 shiyanlou.zip 解压到当前目录：1$ unzip shiyanlou.zip 使用安静模式，将文件解压到指定目录：1$ unzip -q shiyanlou.zip -d ziptest 如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：1$ unzip -l shiyanlou.zip 通常 Windows 系统上面创建的中文名压缩文件，默认会采用 GBK 编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题1unzip -O GBK 中文压缩文件.zip tar打包工具 创建一个 tar 包：12$ cd /home/shiyanlou$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop -c 表示创建一个 tar 包文件 -f 用于指定创建的文件名 -v 以可视的的方式输出打包的文件 解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）： 12$ mkdir tardir$ tar -xf shiyanlou.tar -C tardir 只查看不解包文件 -t 参数：1$ tar -tf shiyanlou.tar 在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件： 1$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop 解压 *.tar.gz 文件：1$ tar -xzf shiyanlou.tar.gz 常用命令zip： 打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数 tar： 打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hololens-basics]]></title>
    <url>%2F2019%2F02%2F14%2Fhololens1%2F</url>
    <content type="text"><![CDATA[同时按住音量的加减键就可以拍照了，不管是不是有应用在运行。 录像是30fps的，并且最长录制5分钟 MRTK(Mixed Reality Toolkit) 是微软为我们提供的混合现实开发工具包，旨在帮助我们加速开发混合现实应用程序。 Hololens 的 Bloom 手势呼出主菜单的效果，主菜单是跟随你移动并且使终面朝你。这就是广告牌（Billboarding） + 平滑追踪（Tag-Along）的联合实现。 空间坐标系 所有的3D图形应用都采用笛卡尔积坐标系。 空间坐标系统以真实世界米为一个单位。 坐标系采用右手定则，X向右为正，Y向上为正，Z向内为正。 坐标参考框架在全息渲染中，有些影像需要跟随用户头部的移动而移动，有些影像在用户头部移动时需要始终保持在固定的位置上。 Hololens 为我们提供了两种参考框架，分别是静止参考框架（Stationary frame of reference） 和附加参考框架（Attached frame of reference）。 附加参考框架附加参照框架中，当用户移动或转动头部的时候，内容也会跟着走。当 Hololens 无法获取空间信息时，就只会渲染基于附加参照框架的全息图。例如程序在丢失空间映射时，弹出一个正在扫描空间信息的界面，来帮助用户。 静止参考框架在编写游戏、VR程序时，传统做法是建立一个，绝对世界坐标系（absolute world coordinate system）。在该坐标系中，可以可靠的获取任意两个物体之间的关系，只要不移动物体的位置，它们的相对位置是保持不变的。 然而在 Hololens 中，动态传感器会随着用户的移动而不断的调整对周围世界的扫描。如果仍然采用一个绝对世界坐标系，随着用户的移动，可能就会导致物体的漂移（drift）。例如假设 Hololens 采用绝对世界坐标系，定义房间左侧角落C1，右侧角落为C2，C1(0,0,0),C2(10,0,0)​C1(0,0,0),C2(10,0,0)​，在C1、C2上分别放置一个全息图，当用户在房间移动时，动态传感器重新扫描，发现 C1 到 C2 的距离只有9.9米，这时 C2(9.9,0,0)​ C2(9.9,0,0)​ ，C2的变化就会导致 C2上的全息图的位置变化，导致物体漂移。 空间锚Hololens 采用空间锚（spatial anchors）来解决这个问题。Hololens 在用户放置全息图的位置上放置空间锚，每一个锚都有一个坐标系统，当用户移动导致动态传感器重新扫描时，Hololens 根据需要调整每个锚的位置，来确保锚上的全息图停留在现实世界的固定位置。 Hololens 支持将空间锚持久化保存（Spatial anchor persistence），这样在相同的环境下再次启动程序时可以加载锚，实现全息图的位置记忆功能。 Hololens 还支持空间锚共享（Spatial anchor sharing），通过将空间锚和周围环境的传感器数据从一个HoloLens 传输到另一个HoloLens。两台设备使用共享的空间锚，使得用户可以在相同位置看到一样的东西。 SpectatorView当我们戴上 Hololens 时，一个没有戴上它的人是无法体验到我们所能体验到的奇迹。 SpectatorView（三方视角）允许其他人通过2D屏幕看到 Hololens 用户在他们的世界里看到的东西。SpectatorView（Preview版）提供一种快速和廉价的途径来录制高清的全息影像，而 SpectatorView Pro 版提供了专业质量记录的全景图。 问题关于textmeshpro的错误 请将刚刚创建的App文件夹整个删掉，在Unity中，点击菜单栏Window &gt; Package Manager，移除TextMesh Pro，如图所示，然后重新导出解决方案即可。 作者：Jitwxs来源：CSDN原文：https://blog.csdn.net/yuanlaijike/article/category/8389122]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>Hololens</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux环境变量]]></title>
    <url>%2F2019%2F02%2F14%2Flinux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量1$ declare tmp 使用 declare 命令创建一个变量名为 tmp 的变量 1$ echo $tmp 读取变量的值 1zsh 创建子shell 1export temp 导出变量temp为环境变量 1gedit hello_shell.sh 创建一个shell脚本文件，第一行 #!/bin/bash 不能省略 1$ PATH=$PATH:/home/shiyanlou/mybin 添加环境变量，可以在任意目录执行mybin里面的文件 1$ echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc 让添加的变量全局有效 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中 &gt; 是以覆盖的方式重定向到一个文件中 1source .zshrc 让环境变量立即生效 1unset temp 删除一个环境变量 环境变量 变量类型： 用户自定义变量 Shell本身内建的变量 从自定义变量导出的环境变量 命 令 说 明 set 显示 Shell 所有变量，包括其内建环境变量，用户自定义变量及导出的环境变量。 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 1/etc/bashrc 存放shell变量 1/etc/profile 存放环境变量 搜索文件与搜索相关的命令常用的有 whereis，which，find和 locate。]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share]]></title>
    <url>%2F2019%2F02%2F09%2Fshare%2F</url>
    <content type="text"><![CDATA[Fun 字母雨 感受静谧 Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，效果很棒。 earth a global map of wind, weather, and ocean conditions. Hololens Mixed Reality HoloLens Solution for Streamlined Shelf Management. 小printf的编程故事 作者仿照《小王子》中的情节，生动有趣的阐述了小printf从编程小白到专家的成长历程。 工具 FetchRSS 将任何网页转为 RSS 的工具。 RSSHub 直接提供各种 Web 应用的 RSS 供订阅。代码开源，可以自己部署。 love2.io 一个收集开源书籍的网站。 鸠摩搜书 一个搜索电子书的网站。 开发者知识库 搜索IT解决方案。 Diagram 手绘图，然后保存成 PPT 的在线服务。 资料 DeviantArt 是一个为艺术家展示各自作品、并交流讨论而设计的社交网路服务网站，里面的壁纸是真的不错。 Crazyflie 对Crazyflie有兴趣可以看看。 A Hololens Hololens的相关资讯。 人间诗语 谁是哪个引起蝴蝶效应的第一个IP包？ 非常在意用电情况，会用任何方式去省电。有一次问他是为什么，他的回答让我们都泪流满面：让这个宇宙的熵，增加的慢一些。 –极客 站在更高一个层次，俯瞰时，很多问题都可以轻易解决。 –思维 美图]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdowm语法]]></title>
    <url>%2F2019%2F01%2F29%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 维基百科 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 优点 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 Markdown的简单语法1234567891011121314151617181920212223242526272829303132333435# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表- 文本1- 文本2- 文本31. 文本12. 文本23. 文本3插入链接[简书](http://www.jianshu.com)插入图片![](图片链接地址)引用在你希望引用的文字前面加上 &gt;斜体*一盏灯*粗体**一简书**表格| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 参考文章：https://www.jianshu.com/p/q81RER]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Root? Root!]]></title>
    <url>%2F2019%2F01%2F21%2Froot%2F</url>
    <content type="text"><![CDATA[小米手机获取完整ROOT权限前言一开始，我只是想删除一些系统自带的软件，以及安装一些需要root权限的app，这里就不细说了，可能我比较爱折腾，也比较想更多地了解一下手机。虽然ROOT一般情况下不会对硬件造成危害，但ROOT后可能会导致系统运行不稳定，耗电大，手机发热，支付有风险的情况。 过程一 : 解锁Bootloader和刷机 解锁Bootloader申请链接 http://www.miui.com/unlock/index.html小米手机解锁Bootloader教程：http://www.miui.com/thread-10101861-1-1.html 升级开发版的卡刷/线刷详细教程，以及MIUI ROM最新刷机包下载链接： http://www.miui.com/shuaji-329.html 解锁和刷机会清除所有数据，请做好备份！ MIUI系统备份与恢复的教程：http://www.miui.com/thread-9605562-1-1.html 二 ：开启ROOT权限 在系统桌面上找到安全中心，并打开。 点击应用管理—权限—开启ROOT权限。 然后等待手机重启。 注意： 稳定版系统不能在授权管理中开启ROOT权限；遇到当前版本撤包，则不能在授权管理中开启ROOT。 解决方法：您可以在电脑上一键刷入recovery，然后卡刷SU。支持直接获取ROOT权限的版本有开发版,内测版和体验版！ 系统提供的ROOT功能并不是完整的；要获取完整的权限，必须解锁System分区！ 三 ：解锁System分区下载解锁分区软件 Syslock，打开界面中的解锁开关，等待手机重启成功即可生效。 结尾其实手机Root并没有难，重要的是敢于探索的精神，要学会使用好网上的搜索引擎，新世界的大门将会向你打开！ 感谢这位大佬 http://api.bbs.miui.com/thread-12281379-1-1.html]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[HexoHexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。 常用命令Create a new post1$ hexo new &quot;My New Post&quot; Run server(启动服务器)1$ hexo server Generate static files(生成静态文件)1$ hexo generate Deploy to remote sites(部署网站。部署网站前，需要预先生成静态文件)1$ hexo deploy clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)1$ hexo clean]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
</search>
