<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux命令执行顺序控制与管道]]></title>
    <url>%2F2019%2F03%2F01%2Flinux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[命令执行顺序的控制顺序执行多条命令eg:1234#更新软件源里的软件列表$ sudo apt-get update$ sudo apt-get install some-tool //这里some-tool是指具体的软件包，例如：banner$ some-tool 有选择的执行命令eg:1$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~ 你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果： ||就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：1$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&quot; 流程图： 管道管道是什么？管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。 管道又分为匿名管道和具名管道，在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示,具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。 先试用一下管道，比如查看/etc目录下有哪些文件和目录，使用ls命令来查看：1$ ls -al /etc 有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：1$ ls -al /etc | less 通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。 cut 命令，打印每一行的某一字段打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：1$ cut /etc/passwd -d &apos;:&apos; -f 1,6 打印/etc/passwd文件中每一行的前N个字符：12345678# 前五个（包含第五个）$ cut /etc/passwd -c -5# 前五个之后的（包含第五个）$ cut /etc/passwd -c 5-# 第五个$ cut /etc/passwd -c 5# 2到5之间的（包含第五个）$ cut /etc/passwd -c 2-5 grep 命令，在文本中或 stdin 中查找匹配字符串grep命令的一般形式为：1grep [命令选项]... 用于匹配的表达式 [文件]... 搜索/home/shiyanlou目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号：1$ grep -rnI &quot;shiyanlou&quot; ~ -r 参数表示递归搜索子目录中的文件 -n表示打印匹配项行号 -I表示忽略二进制文件 当然也可以在匹配字段中使用正则表达式，下面简单的演示： 12# 查看环境变量中以&quot;yanlou&quot;结尾的字符串$ export | grep &quot;.*yanlou$&quot; $表示一行的末尾 wc 命令，简单小巧的计数工具wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：1$ wc /etc/passwd 分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：12345678910# 行数$ wc -l /etc/passwd# 单词数$ wc -w /etc/passwd# 字节数$ wc -c /etc/passwd# 字符数$ wc -m /etc/passwd# 最长行字节数$ wc -L /etc/passwd sort 排序命令这个命令前面我们也是用过多次，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。 默认为字典排序：1$ cat /etc/passwd | sort 反转排序：1$ cat /etc/passwd | sort -r 按特定字段排序：1$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -t参数用于指定字段的分隔符，这里是以”:”作为分隔符； -k 字段号用于指定对哪一个字段进行排序。 这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：1$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n uniq 去重命令uniq命令可以用于过滤或者输出重复行。 过滤重复行我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：1$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq 然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：12$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq# 或者$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u 这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。 输出重复行1234# 输出重复过的行（重复的只输出一个）及重复次数$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc# 输出所有重复的行$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTC VIVE]]></title>
    <url>%2F2019%2F02%2F28%2Fvive1%2F</url>
    <content type="text"><![CDATA[技术规格“HTC Vive”具有90赫兹的刷新速率。该设备使用两个屏幕，每眼一个屏幕，每个屏幕具有1080×1200分辨率。 最低系统要求123456GPU: NVIDIA GeForce GTX 970 / AMD Radeon R9 290 同等或更高的版本CPU: Intel i5-4590 / AMD FX-8350 同等或更高的版本RAM: 4GB+Video Output: HDMI 1.4 或 DisplayPort 1.2 或更高版本USB Port: 1x USB 2.0 或更高版本操作系统: Windows 7 SP1 或更新版本[8] Viveport M简介Viveport M是HTC面向移动市场推出的虚拟现实应用商店，适用于Android平台并广泛兼容多种移动VR设备，其内容将以360°视频和体验类游戏为主，旨在为用户提供更多元化、更高品质的移动VR内容与体验。Viveport M将为全球数以万计的开发者提供一个展示内容的新平台，吸引更多开发者和合作伙伴加入到蓬勃发展的Vive生态系统中，接触到全球增长速度最快的用户群体。系统支持：安卓5.0及以上；屏幕尺寸：5-6寸 手柄1 开关、系统菜单按钮：只有这个按钮不可以编程（默认），用来打开手柄，其实没用关的功能。在游戏中按下该按钮是调出系统默认的菜单，用来关闭，切换游戏用的。 2 menu按钮：默认用来打开游戏菜单。 3 grip按钮：用的最少的按钮，每个手柄上虽然有两个，但是是相同的。 4 trigger按钮：扳机按钮，用的最多，可以有力度。 5 pad：触摸屏+鼠标的功能，可触摸，可点击。 vive开发需要两个插件： SteamVR Plugin Vive Input Utility123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105SteamVR 这个目录下的脚本都是用来定制SteamVR插件中某些脚本在Unity中的Inspector界面及功能的——Editor 定制SteamVR_Camera.cs这个脚本在Inspector中的显示效果 SteamVR_Editor.cs 定制SteamVR_RenderModel.cs脚本在Inspector中的功能 SteamVR_RenderModelEditor.cs 上面提到的弹出的SteamVR_Settings对话框里面的选项就在这儿定制 SteamVR_Settings.cs 定制SteamVR_SkyBox.cs在Inspector中显示的属性 SteamVR_SkyboxEditor.cs 用来检查插件的更新 SteamVR_Update.cs 这个文件夹下面放着一些工具脚本 ——Extras 这个脚本用来检测物体是否被用户所凝视 SteamVR_GazeTracker.cs 通过手柄指向来产生一条激光束 SteamVR_LeaserPointer.cs 用来瞬移的脚本 SteamVR_Teleporter.cs 示例场景中扔物体的脚本 SteamVR_TestThrow.cs 示例场景中跟踪相机的脚本 SteamVR_TestTrackedCamera.cs 控制器(手柄)集成脚本 SteamVR_trackedController.cs 存放示例demo的材质体 ——Materials 存放SteamVR预制体——Prefabs 相机预制体 [CameraRig] 状态相关的overlay显示预制体 [Status] /*SteamVR_Render预制体*/ [SteamVR] /*一些自带的shader*/ ——Scenes/*SteamVR核心脚本*/ ——Scripts /*SteamVR的封装类*/ SteamVR.cs /*SteamVR的核心相机类*/ SteamVR_Camera.cs /*SteamVR相机翻转*/ SteamVR_CameraFlip.cs /*SteamVR相机网格隐藏*/ SteamVR_CameraMask.cs /*控制器封装类*/ SteamVR_Controller.cs /*控制器管理类*/ SteamVR_ControllerManager.cs /*声音控制类*/ SteamVR_Ears.cs /*外部相机*/ SteamVR_ExternalCamera.cs /*场景进行渐显或者渐隐的类*/ SteamVR_Fade.cs /*跟踪设备的扫描范围*/ SteamVR_Frustum.cs /*绘制pc上的伴随窗口*/ SteamVR_GameView.cs /*关节反身运动*/ SteamVR_IK.cs /*场景切换类*/ SteamVR_LoadLevel.cs /*菜单类*/ SteamVR_Menu.cs /*overly封装类*/ SteamVR_Overlay.cs /*运动区域*/ SteamVR_PlayArea.cs /*Vive渲染流程控制的核心类*/ SteamVR_Render.cs /*设置天空盒*/ SteamVR_Skybox.cs /*做球形投影的类*/ SteamVR_SphericalProjection.cs /*通过overlay显示统计信息*/ SteamVR_Stats.cs /*根据不同状态渐变显示不同的信息*/ SteamVR_Status.cs /*根据不同状态渐变显示不同文本信息*/ SteamVR_StatusText.cs /*控制器测试脚本*/ SteamVR_TestController.cs /*头盔上的前置相机*/ SteamVR_TrackedCamera.cs /*跟踪设备管理类*/ SteamVR_TrackedObject.cs /*5.x版本以前更新设备位置的脚本*/ SteamVR_UpdatePoses.cs /*工具类，包括事件系统，Transform等等*/ SteamVR_Utils.cs /*常用的纹理*/ ——Textures]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hololens2]]></title>
    <url>%2F2019%2F02%2F25%2Fhololens2%2F</url>
    <content type="text"><![CDATA[Hololens2售价3500美元 具有强大的环境感知能力，和信息展示能力。强大的本地计算能力（HPU2），还可连接云端后台来增强。 Hololens 2本体的几个亮点： FOV * 2； Hololens 2的FOV大约从30°增加到了52°，同时达到每个视距47像素。 眼球追踪； 眼球追踪也是一个重头戏，Hololens 2 利用了一个小摄像头实现了这个功能。允许其精确追踪你的两只眼睛，并判断具体的注视点位置。与此同时，设备支持Windows Hello和虹膜识别登录，从而允许多人轻松，快速，安全地共享设备。 完全的手指跟踪； 基本上实现了Alex承诺的’instinctual control’。 显示系统: MEMS激光显示器，而且这是当前市场上最小和最高能效的2K显示器。 除了高通骁龙 850 处理器，HoloLens 2 还内置了 AI 处理单元。因此，它能够直接连接到微软的 Azure 云服务。「这意味着某些 AI 任务会被移交给云计算处理，最终的运算结果将会更加精确——类似一厘米空间映射（spatial mapping）和一毫米空间映射的区别。头显处理这些任务仍需几秒钟时间，Kipman 相信这是企业用户可以接受的延迟时长。」《连线》报道称。早在去年 10 月，微软就已推出 Dynamics 365 Remote Assist 和 Dynamics 365 Layout 两个 app。前者为 MR 头显的使用者提供远程帮助；后者将通过云记住用户创建的虚拟图像，并将它固定在特定的地方，以便多名协作用户查找。 在北京时间今天凌晨的 MWC 发布会上，微软推出了全新的员工培训应用 Dynamics 365 Guides。「就好像是为现实世界准备的，能一步步引导你的谷歌地图。」CNET 的记者这样形容。Dynamics 365 Guides 的 PC 端应用还能创建交互式内容，包括添加图片和视频，3D 模型等。 如果将设备连接至全新的Azure Remote Rendering混合现实云端服务，你将可以快速生成复杂的三维数字模型，而原本企业可能需要花费数天或数月的时间才能构建出与之媲美的模型细节。如果没有云端的图形处理能力，这是不可能实现的任务。Azure Remote Rendering可以帮助人们自由体验3D，从而实现更快，更优的决策。微软认为，今天如果要通过移动设备和混合现实头显与高质量3D模型进行交互，你通常需要“抽取”或简化3D模型。但对于设计评审和医疗规划等场景，每个细节都非常重要，而简化asset可能会导致关键决策所需的重要细节丢失。Azure Remote Rendering可以在云端渲染高质量的3D内容，并将其全部实时传输至边缘设备，而且能够确保“每个细节都完好无损”。 如果把未来的公司比作一个厨房，那么云服务大概是水电煤，数据就是基础原料，AI算法服务是不同的菜谱，操作系统则是一台功能齐备的厨师机，目前这厨房里的所有设备微软全都齐备，并且都在为未来布局。 技术规格:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748光学：透视全息透镜（波导）分辨率：2k 3：2光引擎全息密度：&gt; 2.5k辐射点（每弧度光点）注视点渲染：针对3D眼睛位置显示的优化深度传感器：Azure Kinect传感器IMU：加速度计，陀螺仪，磁力计摄像头：800万像素，1080P/30帧视频麦克风阵列：5组扬声器：内置空间音频手部追踪：双手全关节模型，直接操纵眼动追踪：实时追踪语音 ：板载命令与控制，具有互联网连接的自然语言六自由度追踪：世界规模的位置追踪空间映射：实时环境网格混合现实捕获：混合全息图和物理环境照片和视频SoC：高通骁龙850计算平台，不支持4G LTEHPU：第二代定制全息处理单元WiFi：802.11ac 2×2蓝牙：5.0USB：USB Type-C续航能力：2-3小时的有效使用时间充电：USB供电 – 快速充电热量：被动冷却佩戴：适合眼镜，可使用表盘调节 Azure Kinect微软同时发布了一款新的Azure Kinect设备，为开发者提供了创建人工智能体验的新方式。Azure Kinect将HoloLens 2中的深度感应摄像头技术与圆形麦克风阵列和彩色摄像头相结合，并搭配以Microsoft Azure中的人工智能服务。它可以帮助开发者建立新的感知功能，如根据锯子的声音识别其是否属于危险的运行情况，支持机器人在装箱时判断距离，或者是识别从商店货架中选择的物品。 第四代的Kinect，结合了在边缘运行的AI工具。这种深度和动作感知技术最初是在十年前开发，并旨在为Xbox创建手势识别附件。但对于可以准确感知深度并确定人体在空间中移动的能力，其潜力远远不局限于游戏。例如，Ocuvera正与Azure Kinect合作开发这样一种系统：旨在帮助防止每年在美国医院发生的大约100万次跌倒，甚至是全球范围内的更多跌倒。他们研发的系统可以感知需要帮助行走的患者是于何时无助地下床，并提前预警护士以提供帮助。利用深度感应摄像头和人工智能算法，系统可以在患者起床前识别出运动模式，如坐起或摆动腿部的动作。11个临床试点的初步研究结果发现，在实施上述技术后，无辅助和未留意的下床行走减少了90％以上。首席执行官史蒂夫·凯恩（Steve Kiene）表示，Ocuvera团队调查了世界每一台深度感应摄像头，甚至试图开发自家的深度感应摄像头。但对于区分病人是向前移动抑或只是翻身，没有任何一款设备能够接近于Azure Kinect的准确性和分辨率。他说道：“这就像玩扑克时的认牌一样。只有Azure Kinect能够为我们提供可以真正了解患者在病床上发生的情况，并以足够的准确度预测其意图的数据。当我们在医院进行试点测试时，他们经常告诉我们这是不可能的做到的事情，但随后他们发现它确实有效，而且他们感到非常惊讶。” 参考文章 售价3500美元，中国首发，微软HoloLens 2正式发布 - 映维网 十年一剑！微软HoloLens 2是如何沸腾下一代计算平台 - 映维网]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>Hololens</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux帮助命令和crontab]]></title>
    <url>%2F2019%2F02%2F21%2Flinux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[内建命令与外部命令可以用type来区分命令是内建的还是外部的1type + 命令 内建命令是写在bash源码的builtins里面的 外部命令通常放在/bin，/user/bin,/sbin,/usr/sbin等等 crontab语法用于设置周期性被执行的指令。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。 crontab 的格式:12345678# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 12$ crontab -e 表示为当前用户添加计划任务$ sudo crontab -e 表示为root用户添加计划任务]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 反射（Reflection）]]></title>
    <url>%2F2019%2F02%2F21%2Fc%20sharp%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射（Reflection）的用途反射（Reflection）有下列用途： 它允许在运行时查看特性（attribute）信息。 它允许审查集合中的各种类型，以及实例化这些类型。 它允许延迟绑定的方法和属性（property）。 它允许在运行时创建新类型，然后使用这些类型执行一些任务。 查看元数据使用反射（Reflection）可以查看特性（attribute）信息。 System.Reflection 类的 MemberInfo 对象需要被初始化，用于发现与类相关的特性（attribute）。为了做到这点，您可以定义目标类的一个对象，如下：1System.Reflection.MemberInfo info = typeof(MyClass); 下面的程序演示了这点：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;[AttributeUsage(AttributeTargets.All)]public class HelpAttribute : System.Attribute&#123; public readonly string Url; public string Topic // Topic 是一个命名（named）参数 &#123; get &#123; return topic; &#125; set &#123; topic = value; &#125; &#125; public HelpAttribute(string url) // url 是一个定位（positional）参数 &#123; this.Url = url; &#125; private string topic;&#125;[HelpAttribute(&quot;Information on the class MyClass&quot;)]class MyClass&#123;&#125;namespace AttributeAppl&#123; class Program &#123; static void Main(string[] args) &#123; System.Reflection.MemberInfo info = typeof(MyClass); object[] attributes = info.GetCustomAttributes(true); for (int i = 0; i &lt; attributes.Length; i++) &#123; System.Console.WriteLine(attributes[i]); &#125; Console.ReadKey(); &#125; &#125;&#125; 当上面的代码被编译和执行时，它会显示附加到类 MyClass 上的自定义特性：1HelpAttribute]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 特性（Attribute）]]></title>
    <url>%2F2019%2F02%2F21%2Fc%20sharp%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。 .Net 框架提供了两种类型的特性：预定义特性和自定义特性。 预定义特性（Attribute）.Net 框架提供了三种预定义特性： AttributeUsage Conditional Obsolete 创建自定义特性（Attribute）创建并使用自定义特性包含四个步骤： 声明自定义特性 构建自定义特性 在目标程序元素上应用自定义特性 通过反射访问特性 声明自定义特性一个新的自定义特性应派生自 System.Attribute 类。例如： 123456789// 一个自定义特性 BugFix 被赋给类及其成员[AttributeUsage(AttributeTargets.Class |AttributeTargets.Constructor |AttributeTargets.Field |AttributeTargets.Method |AttributeTargets.Property,AllowMultiple = true)]public class DeBugInfo : System.Attribute 在上面的代码中，我们已经声明了一个名为 DeBugInfo 的自定义特性。 构建自定义特性让我们构建一个名为 DeBugInfo 的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息： bug 的代码编号 辨认该 bug 的开发人员名字 最后一次审查该代码的日期 一个存储了开发人员标记的字符串消息 我们的 DeBugInfo 类将带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（property）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，消息将是一个可选的命名（named）参数。 每个特性必须至少有一个构造函数。必需的定位（ positional）参数应通过构造函数传递。下面的代码演示了 DeBugInfo 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 一个自定义特性 BugFix 被赋给类及其成员[AttributeUsage(AttributeTargets.Class |AttributeTargets.Constructor |AttributeTargets.Field |AttributeTargets.Method |AttributeTargets.Property,AllowMultiple = true)]public class DeBugInfo : System.Attribute&#123; private int bugNo; private string developer; private string lastReview; public string message; public DeBugInfo(int bg, string dev, string d) &#123; this.bugNo = bg; this.developer = dev; this.lastReview = d; &#125; public int BugNo &#123; get &#123; return bugNo; &#125; &#125; public string Developer &#123; get &#123; return developer; &#125; &#125; public string LastReview &#123; get &#123; return lastReview; &#125; &#125; public string Message &#123; get &#123; return message; &#125; set &#123; message = value; &#125; &#125;&#125; 应用自定义特性通过把特性放置在紧接着它的目标之前，来应用该特性：1234567891011121314151617181920212223242526[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)][DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]class Rectangle&#123; // 成员变量 protected double length; protected double width; public Rectangle(double l, double w) &#123; length = l; width = w; &#125; [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;, Message = &quot;Return type mismatch&quot;)] public double GetArea() &#123; return length * width; &#125; [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)] public void Display() &#123; Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length); Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width); Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea()); &#125;&#125;]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牧云集-1]]></title>
    <url>%2F2019%2F02%2F21%2F%E7%89%A7%E4%BA%91%E9%9B%86-1%2F</url>
    <content type="text"><![CDATA[故事1 新郎，特地和司仪要了话筒，说了一段话，他说他父母婚姻不幸，心里那个自己，从来没有长大过。 从来我不是不爱你，不是一次次想要推开你。不是心有不忿意难平。这世间，离别太多。 太美好的你，怕握不住。 嗯，那个戒指，他配了项链挂在胸口。忽然明白，为什么十年，依旧是他们两个。 或许女孩子从来不卑微，她知道命中注定就是他。 嗯，我一直看见的婚礼都是新娘哭，新郎笑。 今天第一次看见新郎哭得双肩耸动，新娘笑着安慰，帮他抹泪。 很甜！ 故事二 高中时一个同学沉迷网络 时常半夜翻墙出校上网 一日他照例翻墙 翻到一半就拔足狂奔而归 面色古怪，问之不语 从此认真读书，不再上网 学校盛传他见鬼了 后来他考上名校，我们问起这事 他沉默良久，说 “那天父亲来送生活费 舍不得住旅馆，在墙下坐了一夜”]]></content>
      <categories>
        <category>洛书</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python-1]]></title>
    <url>%2F2019%2F02%2F16%2Fpython1%2F</url>
    <content type="text"><![CDATA[输入与输出12name = input(&apos;please enter your name: &apos;)print(&apos;hello,&apos;, name) python基础 Python允许用r’’表示’’内部的字符串默认不转义 1234print(&apos;\\\t\\&apos;)\ \print(r&apos;\\\t\\&apos;)\\\t\\ 如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容, ...是提示符，不是代码的一部分 12print(r&apos;&apos;&apos;hello,world&apos;&apos;&apos;) 一个布尔值只有True、False两种值,布尔值可以用and、or和not运算。 用全部大写的变量名表示常量只是一个习惯上的用法 , eg: PI 除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 129 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数：1210 // 33 Python的整数没有大小限制，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。 字符编码 美国ASCII编码 中国GB2312编码 Unicode统一编码 -&gt; UTF-8编码(可变长编码) 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器 Python的字符串对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：12345678&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos; 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示：1x = b&apos;ABC&apos; 要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：12345678&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：1234&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)&apos;ABC&apos;&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)&apos;中文&apos; 如果bytes中包含无法解码的字节，decode()方法会报错：1234&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;)Traceback (most recent call last): ...UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte 如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节：12&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)&apos;中&apos; 要计算str包含多少个字符，可以用len()函数：1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：123456&gt;&gt;&gt; len(b&apos;ABC&apos;)3&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)6&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))6 格式化在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：1234&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos; 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pycharm-basics]]></title>
    <url>%2F2019%2F02%2F16%2Fpycharm%2F</url>
    <content type="text"><![CDATA[常用的默认快捷键： 调试栏的几个重要的按钮作用： Resume Program：断点调试后，点击按钮，继续执行程序； Step Over ：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和Step Into效果一样的（简而言之，越过子函数，但子函数会执行）； Step Into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）； Step Out ： 当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。 PythonPython报错TypeError: ‘&lt;’ not supported between instances of ‘str’ and ‘int’input()返回的数据类型是str，不能直接和整数进行比较，必须先把str换成整数，使用int()方法1231 n = int(input(&quot;Input a number:&quot;))2 if n&gt;=100:print(int(n)/10)3 else:print(int(n)*10)]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件系统操作与磁盘管理]]></title>
    <url>%2F2019%2F02%2F16%2Flinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[查看磁盘和目录的容量 使用df命令查看磁盘的容量12$ df$ df -h 使用du命令查看目录的容量 1234# 默认同样以 块 的大小展示$ du# 加上-h参数，以更易读的方式展示$ du -h -d 参数指定查看目录的深度1234# 只查看1级目录的信息$ du -h -d 0 ~# 查看2级$ du -h -d 1 ~ 常用参数123du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。du -a #同--all 显示目录中所有文件的大小。du -s #同--summarize 仅显示总计，只列出最后加总的值。 创建虚拟磁盘 用dd命令从标准输入读入用户的输入到标准输出或者一个文件中： 12345# 输出到文件$ dd of=test bs=10 count=1# 输出到标准输出$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1# 注:在打完了这个命令后，继续在终端打字，作为你的输入 bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。 将输出的英文字符转换为大写再写入文件：1$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase 使用 dd 命令创建虚拟镜像文件 从/dev/zero设备创建一个容量为 256M 的空文件：12$ dd if=/dev/zero of=virtual.img bs=1M count=256$ du -h virtual.img 使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像） $ sudo mkfs.ext4 virtual.img 使用 mount 命令挂载磁盘到目录树 mount命令的一般格式如下： 1mount [options] [source] [directory] 一些常用操作： 1mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-basics]]></title>
    <url>%2F2019%2F02%2F16%2Flinux%2F</url>
    <content type="text"><![CDATA[Linux的几个优点： 免费 很多软件原生是在Linux下运行的，庞大的社区支持，生态环境好。 开源，可被定制，开放，多用户的网络操作系统。 相对安全稳定 ## bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 作者：Java3y链接：https://www.jianshu.com/p/a182a0be4b8a]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux压缩解压工具]]></title>
    <url>%2F2019%2F02%2F15%2Flinux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%2F</url>
    <content type="text"><![CDATA[压缩文件linux常见格式：.zip,.rar,.7z,.tar,.gz,.xz,.bz2,.tar.gz,.tar.xz,tar.bz2,.tar.7z zip压缩打包程序使用zip打包文件夹1234$ cd /home/shiyanlou$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop$ du -h shiyanlou.zip$ file shiyanlou.zip -r 参数表示递归打包包含子目录的全部内容， -q 参数表示为安静模式，即不向屏幕输出信息， -o，表示输出文件，需在其后紧跟打包输出文件名。 du ,命令查看打包后文件的大小 设置压缩级别为9和1（9最大，1最小），重新打包：12$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip -[1-9] 表示压缩级别，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意：这里只能使用绝对路径，否则不起作用。 创建加密 zip 包使用 -e 参数可以创建加密压缩包：1$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop 如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题,需要加上 -l参数将LF 转换为 CR+LF1$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop 使用 unzip 命令解压缩 zip 文件将 shiyanlou.zip 解压到当前目录：1$ unzip shiyanlou.zip 使用安静模式，将文件解压到指定目录：1$ unzip -q shiyanlou.zip -d ziptest 如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：1$ unzip -l shiyanlou.zip 通常 Windows 系统上面创建的中文名压缩文件，默认会采用 GBK 编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题1unzip -O GBK 中文压缩文件.zip tar打包工具 创建一个 tar 包：12$ cd /home/shiyanlou$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop -c 表示创建一个 tar 包文件 -f 用于指定创建的文件名 -v 以可视的的方式输出打包的文件 解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）： 12$ mkdir tardir$ tar -xf shiyanlou.tar -C tardir 只查看不解包文件 -t 参数：1$ tar -tf shiyanlou.tar 在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件： 1$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop 解压 *.tar.gz 文件：1$ tar -xzf shiyanlou.tar.gz 常用命令zip： 打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数 tar： 打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hololens-basics]]></title>
    <url>%2F2019%2F02%2F14%2Fhololens1%2F</url>
    <content type="text"><![CDATA[同时按住音量的加减键就可以拍照了，不管是不是有应用在运行。 录像是30fps的，并且最长录制5分钟 MRTK(Mixed Reality Toolkit) 是微软为我们提供的混合现实开发工具包，旨在帮助我们加速开发混合现实应用程序。 Hololens 的 Bloom 手势呼出主菜单的效果，主菜单是跟随你移动并且使终面朝你。这就是广告牌（Billboarding） + 平滑追踪（Tag-Along）的联合实现。 空间坐标系 所有的3D图形应用都采用笛卡尔积坐标系。 空间坐标系统以真实世界米为一个单位。 坐标系采用右手定则，X向右为正，Y向上为正，Z向内为正。 坐标参考框架在全息渲染中，有些影像需要跟随用户头部的移动而移动，有些影像在用户头部移动时需要始终保持在固定的位置上。 Hololens 为我们提供了两种参考框架，分别是静止参考框架（Stationary frame of reference） 和附加参考框架（Attached frame of reference）。 附加参考框架附加参照框架中，当用户移动或转动头部的时候，内容也会跟着走。当 Hololens 无法获取空间信息时，就只会渲染基于附加参照框架的全息图。例如程序在丢失空间映射时，弹出一个正在扫描空间信息的界面，来帮助用户。 静止参考框架在编写游戏、VR程序时，传统做法是建立一个，绝对世界坐标系（absolute world coordinate system）。在该坐标系中，可以可靠的获取任意两个物体之间的关系，只要不移动物体的位置，它们的相对位置是保持不变的。 然而在 Hololens 中，动态传感器会随着用户的移动而不断的调整对周围世界的扫描。如果仍然采用一个绝对世界坐标系，随着用户的移动，可能就会导致物体的漂移（drift）。例如假设 Hololens 采用绝对世界坐标系，定义房间左侧角落C1，右侧角落为C2，C1(0,0,0),C2(10,0,0)​C1(0,0,0),C2(10,0,0)​，在C1、C2上分别放置一个全息图，当用户在房间移动时，动态传感器重新扫描，发现 C1 到 C2 的距离只有9.9米，这时 C2(9.9,0,0)​ C2(9.9,0,0)​ ，C2的变化就会导致 C2上的全息图的位置变化，导致物体漂移。 空间锚Hololens 采用空间锚（spatial anchors）来解决这个问题。Hololens 在用户放置全息图的位置上放置空间锚，每一个锚都有一个坐标系统，当用户移动导致动态传感器重新扫描时，Hololens 根据需要调整每个锚的位置，来确保锚上的全息图停留在现实世界的固定位置。 Hololens 支持将空间锚持久化保存（Spatial anchor persistence），这样在相同的环境下再次启动程序时可以加载锚，实现全息图的位置记忆功能。 Hololens 还支持空间锚共享（Spatial anchor sharing），通过将空间锚和周围环境的传感器数据从一个HoloLens 传输到另一个HoloLens。两台设备使用共享的空间锚，使得用户可以在相同位置看到一样的东西。 SpectatorView当我们戴上 Hololens 时，一个没有戴上它的人是无法体验到我们所能体验到的奇迹。 SpectatorView（三方视角）允许其他人通过2D屏幕看到 Hololens 用户在他们的世界里看到的东西。SpectatorView（Preview版）提供一种快速和廉价的途径来录制高清的全息影像，而 SpectatorView Pro 版提供了专业质量记录的全景图。 问题关于textmeshpro的错误 请将刚刚创建的App文件夹整个删掉，在Unity中，点击菜单栏Window &gt; Package Manager，移除TextMesh Pro，如图所示，然后重新导出解决方案即可。 作者：Jitwxs来源：CSDN原文：https://blog.csdn.net/yuanlaijike/article/category/8389122]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>Hololens</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux环境变量]]></title>
    <url>%2F2019%2F02%2F14%2Flinux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量1$ declare tmp 使用 declare 命令创建一个变量名为 tmp 的变量 1$ echo $tmp 读取变量的值 1zsh 创建子shell 1export temp 导出变量temp为环境变量 1gedit hello_shell.sh 创建一个shell脚本文件，第一行 #!/bin/bash 不能省略 1$ PATH=$PATH:/home/shiyanlou/mybin 添加环境变量，可以在任意目录执行mybin里面的文件 1$ echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc 让添加的变量全局有效 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中 &gt; 是以覆盖的方式重定向到一个文件中 1source .zshrc 让环境变量立即生效 1unset temp 删除一个环境变量 环境变量 变量类型： 用户自定义变量 Shell本身内建的变量 从自定义变量导出的环境变量 命 令 说 明 set 显示 Shell 所有变量，包括其内建环境变量，用户自定义变量及导出的环境变量。 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。 export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。 按变量的生存周期来划分，Linux 变量可分为两类： 永久的：需要修改配置文件，变量永久生效； 临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。 1/etc/bashrc 存放shell变量 1/etc/profile 存放环境变量 搜索文件与搜索相关的命令常用的有 whereis，which，find和 locate。]]></content>
      <categories>
        <category>河图</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share]]></title>
    <url>%2F2019%2F02%2F09%2Fshare%2F</url>
    <content type="text"><![CDATA[Fun 字母雨 感受静谧 Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，效果很棒。 earth a global map of wind, weather, and ocean conditions. Hololens Mixed Reality HoloLens Solution for Streamlined Shelf Management. 小printf的编程故事 作者仿照《小王子》中的情节，生动有趣的阐述了小printf从编程小白到专家的成长历程。 工具 FetchRSS 将任何网页转为 RSS 的工具。 RSSHub 直接提供各种 Web 应用的 RSS 供订阅。代码开源，可以自己部署。 love2.io 一个收集开源书籍的网站。 鸠摩搜书 一个搜索电子书的网站。 开发者知识库 搜索IT解决方案。 Diagram 手绘图，然后保存成 PPT 的在线服务。 资料 DeviantArt 是一个为艺术家展示各自作品、并交流讨论而设计的社交网路服务网站，里面的壁纸是真的不错。 Crazyflie 对Crazyflie有兴趣可以看看。 A Hololens Hololens的相关资讯。 人间诗语 谁是哪个引起蝴蝶效应的第一个IP包？ 非常在意用电情况，会用任何方式去省电。有一次问他是为什么，他的回答让我们都泪流满面：让这个宇宙的熵，增加的慢一些。 –极客 站在更高一个层次，俯瞰时，很多问题都可以轻易解决。 –思维 美图]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdowm语法]]></title>
    <url>%2F2019%2F01%2F29%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 维基百科 Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 优点 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 Markdown的简单语法1234567891011121314151617181920212223242526272829303132333435# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 列表- 文本1- 文本2- 文本31. 文本12. 文本23. 文本3插入链接[简书](http://www.jianshu.com)插入图片![](图片链接地址)引用在你希望引用的文字前面加上 &gt;斜体*一盏灯*粗体**一简书**表格| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 参考文章：https://www.jianshu.com/p/q81RER]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Root? Root!]]></title>
    <url>%2F2019%2F01%2F21%2Froot%2F</url>
    <content type="text"><![CDATA[小米手机获取完整ROOT权限前言一开始，我只是想删除一些系统自带的软件，以及安装一些需要root权限的app，这里就不细说了，可能我比较爱折腾，也比较想更多地了解一下手机。虽然ROOT一般情况下不会对硬件造成危害，但ROOT后可能会导致系统运行不稳定，耗电大，手机发热，支付有风险的情况。 过程一 : 解锁Bootloader和刷机 解锁Bootloader申请链接 http://www.miui.com/unlock/index.html小米手机解锁Bootloader教程：http://www.miui.com/thread-10101861-1-1.html 升级开发版的卡刷/线刷详细教程，以及MIUI ROM最新刷机包下载链接： http://www.miui.com/shuaji-329.html 解锁和刷机会清除所有数据，请做好备份！ MIUI系统备份与恢复的教程：http://www.miui.com/thread-9605562-1-1.html 二 ：开启ROOT权限 在系统桌面上找到安全中心，并打开。 点击应用管理—权限—开启ROOT权限。 然后等待手机重启。 注意： 稳定版系统不能在授权管理中开启ROOT权限；遇到当前版本撤包，则不能在授权管理中开启ROOT。 解决方法：您可以在电脑上一键刷入recovery，然后卡刷SU。支持直接获取ROOT权限的版本有开发版,内测版和体验版！ 系统提供的ROOT功能并不是完整的；要获取完整的权限，必须解锁System分区！ 三 ：解锁System分区下载解锁分区软件 Syslock，打开界面中的解锁开关，等待手机重启成功即可生效。 结尾其实手机Root并没有难，重要的是敢于探索的精神，要学会使用好网上的搜索引擎，新世界的大门将会向你打开！ 感谢这位大佬 http://api.bbs.miui.com/thread-12281379-1-1.html]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[HexoHexo的命令极简单，安装后只需要记住四个常用的即可。执行命令需要Git当前处于blog文件夹根目录下。 常用命令Create a new post1$ hexo new &quot;My New Post&quot; Run server(启动服务器)1$ hexo server Generate static files(生成静态文件)1$ hexo generate Deploy to remote sites(部署网站。部署网站前，需要预先生成静态文件)1$ hexo deploy clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)1$ hexo clean]]></content>
      <categories>
        <category>河图</category>
      </categories>
  </entry>
</search>
