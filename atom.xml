<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏牧云</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-08T12:13:00.788Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>苏牧云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单的文本处理</title>
    <link href="http://yoursite.com/2019/03/08/linux%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/08/linux简单的文本处理/</id>
    <published>2019-03-08T11:52:27.142Z</published>
    <updated>2019-03-08T12:13:00.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h2><p>tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 删除 &quot;hello shiyanlou&quot; 中所有的&apos;o&apos;,&apos;l&apos;,&apos;h&apos;</span><br><span class="line">$ echo &apos;hello shiyanlou&apos; | tr -d &apos;olh&apos;</span><br><span class="line"># 将&quot;hello&quot; 中的ll,去重为一个l</span><br><span class="line">$ echo &apos;hello&apos; | tr -s &apos;l&apos;</span><br><span class="line"># 将输入文本，全部转换为大写或小写输出</span><br><span class="line">$ echo &apos;input some text here&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;</span><br><span class="line"># 上面的&apos;[:lower:]&apos; &apos;[:upper:]&apos;你也可以简单的写作&apos;[a-z]&apos; &apos;[A-Z]&apos;,当然反过来将大写变小写也是可以的</span><br></pre></td></tr></table></figure><h2 id="col命令"><a href="#col命令" class="headerlink" title="col命令"></a>col命令</h2><p>col 命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col [option]</span><br></pre></td></tr></table></figure><h3 id="常用的选项有："><a href="#常用的选项有：" class="headerlink" title="常用的选项有："></a>常用的选项有：</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-x</td><td>将Tab转换为空格</td></tr><tr><td>-h</td><td>将空格转换为Tab(默认选项)</td></tr></tbody></table><h2 id="join命令"><a href="#join命令" class="headerlink" title="join命令"></a>join命令</h2><p>join命令可以将将两个文件中包含相同内容的那一行合并在一起。</p><h3 id="常用的选项有：-1"><a href="#常用的选项有：-1" class="headerlink" title="常用的选项有："></a>常用的选项有：</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定分隔符，默认为空格</td></tr><tr><td>-i</td><td>忽略大小写的差异</td></tr><tr><td>-1</td><td>指名第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td>-2</td><td>指名第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/shiyanlou</span><br><span class="line"># 创建两个文件</span><br><span class="line">$ echo &apos;1 hello&apos; &gt; file1</span><br><span class="line">$ echo &apos;1 shiyanlou&apos; &gt; file2</span><br><span class="line">$ join file1 file2</span><br><span class="line"># 将/etc/passwd与/etc/shadow两个文件合并，指定以&apos;:&apos;作为分隔符</span><br><span class="line">$ sudo join -t&apos;:&apos; /etc/passwd /etc/shadow</span><br><span class="line"># 将/etc/passwd与/etc/group两个文件合并，指定以&apos;:&apos;作为分隔符, 分别比对第4和第3个字段</span><br><span class="line">$ sudo join -t&apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group</span><br></pre></td></tr></table></figure><h2 id="paste-命令"><a href="#paste-命令" class="headerlink" title="paste 命令"></a>paste 命令</h2><p><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</p><h3 id="常用的选项有：-2"><a href="#常用的选项有：-2" class="headerlink" title="常用的选项有："></a>常用的选项有：</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>指定合并的分隔符，默认为Tab</td></tr><tr><td>-s</td><td>不合并到一行，每个文件为一行</td></tr></tbody></table><h3 id="操作举例："><a href="#操作举例：" class="headerlink" title="操作举例："></a>操作举例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello &gt; file1</span><br><span class="line">$ echo shiyanlou &gt; file2</span><br><span class="line">$ echo www.shiyanlou.com &gt; file3</span><br><span class="line">$ paste -d &apos;:&apos; file1 file2 file3</span><br><span class="line">$ paste -s file1 file2 file3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tr命令&quot;&gt;&lt;a href=&quot;#tr命令&quot; class=&quot;headerlink&quot; title=&quot;tr命令&quot;&gt;&lt;/a&gt;tr命令&lt;/h2&gt;&lt;p&gt;tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>HTC VIVE - 2</title>
    <link href="http://yoursite.com/2019/03/03/vive2/"/>
    <id>http://yoursite.com/2019/03/03/vive2/</id>
    <published>2019-03-03T13:07:31.558Z</published>
    <updated>2019-03-04T02:23:22.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SteamVR渲染机制"><a href="#SteamVR渲染机制" class="headerlink" title="SteamVR渲染机制"></a>SteamVR渲染机制</h2><ol><li>等待相机和GUI的渲染完成</li><li>设置跟踪空间</li><li>获取设备位置，通知更新</li><li>渲染外部相机</li><li>渲染左右眼</li></ol><h2 id="vive的基站工作原理"><a href="#vive的基站工作原理" class="headerlink" title="vive的基站工作原理"></a>vive的基站工作原理</h2><p>vive的基站工作原理有点像超市买东西用来扫描的扫描器，不够那个用的是可见激光，vive用的是不可见激光（红外线)。<br>结构：<br>基站里面有两个马达，一个横着转一个竖着转。他们上面有一个激光发射器发出一道很细的不可见激光，随着马达的转动它们射出的激光线扫过整个房间。中间有一个红外列阵。</p><p><img src="http://www.52vr.com/data/attachment/portal/201605/06/185933l88s9qrgj4sjbpp4.jpg" alt=""></p><p>红色的是激光发射器（在马达上的）绿色的是红外列阵。<br>原理：</p><ol><li>基站会频繁的发出4个信号，第一是由红外列阵发出的红外线，代表开始扫描，可以覆盖整个追踪面积；第二竖向激光扫描，第三是横向激光扫描，第四又是由红外列阵发出的，代表扫描结束。</li><li>vive和vive控制器上有多个红外接收器，它们会接受第一个信号并且开始计时，当2个信号被接收到的时候结束竖向计时，第3个信号结束横向计时，第四个信号重置。</li><li>因为马达的转速是已知的，所以通过时间差可以计算出接收点相对接收器的位置，又因为基站是固定的，可以计算出接收点的位置。</li><li>接收器上有多个接收点，通过接收点之间的距离可以计算出vive头显和控制器的完全位置以及状态。</li></ol><p><img src="http://www.52vr.com/data/attachment/portal/201605/06/185934x7yt0j143r20xyrx.jpg" alt=""></p><p>竖向扫描</p><p><img src="http://www.52vr.com/data/attachment/portal/201605/06/185934zkyvb8giivhx4bii.jpg" alt=""></p><p>横向扫描</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SteamVR渲染机制&quot;&gt;&lt;a href=&quot;#SteamVR渲染机制&quot; class=&quot;headerlink&quot; title=&quot;SteamVR渲染机制&quot;&gt;&lt;/a&gt;SteamVR渲染机制&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;等待相机和GUI的渲染完成&lt;/li&gt;
&lt;li&gt;设置跟踪空
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="VR" scheme="http://yoursite.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>Share-2</title>
    <link href="http://yoursite.com/2019/03/02/share-2/"/>
    <id>http://yoursite.com/2019/03/02/share-2/</id>
    <published>2019-03-02T05:35:42.810Z</published>
    <updated>2019-03-08T13:13:20.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fun"><a href="#Fun" class="headerlink" title="Fun"></a>Fun</h2><ol><li><p><a href="https://danielmiessler.com/blog/dns-servers-you-should-have-memorized/" target="_blank" rel="noopener">DNS Servers That Offer Privacy and Filtering</a></p><p> 作者介绍了几个常用的DNS服务器地址，简单谈了它们之间的差异。</p></li></ol><ol start="2"><li><p><a href="https://thispersondoesnotexist.com/" target="_blank" rel="noopener">This Person Does Not Exist</a></p><p>这个网站，每刷新一次就会出现一张人脸。所有的人脸都是AI生成的，现实中不存在。</p></li></ol><ol start="3"><li><p>猫屎咖啡</p><p>猫屎咖啡是世界上最贵的咖啡之一，是印尼麝香猫吃下咖啡浆果排泄出的咖啡豆制成的。过去，人们是在树林捡拾野生麝香猫排泄的天然咖啡豆，数量稀少且生产速度慢，于是咖啡商人开始人工养殖麝香猫，以求大量生产猫屎咖啡。</p></li></ol><ol start="4"><li><p>乐器博物馆</p><p> 意大利克雷莫纳，历史上是一个著名的小提琴制作城市。著名的斯特拉迪瓦里小提琴，就是在那里制作的。下图是当地的小提琴博物馆。</p></li></ol><ol start="5"><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjEyOTIyMA==&amp;mid=2651467048&amp;idx=1&amp;sn=1273aa18d189186e38d448d0662ebda3" target="_blank" rel="noopener">《流浪地球》超详细设计图、理念分享</a></li></ol><p><img src="\images\four.jpg" alt=""></p><ol start="5"><li><p>估计日落的时间</p><p> <img src="https://www.wangbase.com/blogimg/asset/201902/bg2019022233.jpg" alt=""></p><p> 太阳将要落山的时候，你可以把手放在太阳和地平线之间，估计日落的大概时间。如果可以放四根手指，就是1个小时后落山，三根手指45分钟，两根手指30分钟，一根手指15分钟。</p></li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><p><a href="https://www.lucidchart.com/" target="_blank" rel="noopener">LucidChart</a><br> 一款流程图工具，与大家熟知的 ProcessOn 功能操作类似，但图形和模板更丰富些，如果你受不了 ProcessOn 的种种小毛病，或者觉得模板不漂亮，可以试试这款工具。</p><p> <img src="https://ws1.sinaimg.cn/large/62bfa70bly1g0nd1ytfq6j21r20nan07.jpg" alt=""></p></li><li><p><a href="https://github.com/cool2528/baiduCDP" target="_blank" rel="noopener">百度网盘下载神器</a><br> <img src="https://camo.githubusercontent.com/eeff5737a538c133de62d291514d22c8b5d5e1a2/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f32312f356336653161356539626261352e676966" alt=""></p></li></ol><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li><p><a href="http://stevesspace.com/2019/02/how-does-hololens2-matter/" target="_blank" rel="noopener">How does the Hololens 2 matter? </a></p><p> This release is super exciting, I can’t wait to get my hands on one and see what it can do.</p></li><li><p><a href="https://functionalcs.github.io/curriculum/" target="_blank" rel="noopener">计算机科学的自学方案</a></p><p> 本文对于计算机科学各门课程的自学，给出了一个完整的方案。</p></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li><p><a href="https://mp.weixin.qq.com/s/ijNTMluqmGgDdZx56REdCQ" target="_blank" rel="noopener">施一公：如何成为一名优秀的博士生？</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22581673" target="_blank" rel="noopener">什么是点云？</a></p></li><li><p><a href="https://jerryding.site/linux-experience/" target="_blank" rel="noopener">使用Linux系统是一种怎样的体验</a></p></li></ol><h2 id="藏经阁"><a href="#藏经阁" class="headerlink" title="藏经阁"></a>藏经阁</h2><ul><li><p>回顾其过去，能看清其千丝万缕的联系。</p></li><li><p>要学会挖掘数据背后的潜在价值。</p></li><li><p>越是复杂的问题，背后的原来越是简单。有时候，应该让生活过得简单一些。</p></li></ul><h2 id="藏宝图"><a href="#藏宝图" class="headerlink" title="藏宝图"></a>藏宝图</h2><p><img src="\images\two.jpg" alt="编程语言排行榜"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Fun&quot;&gt;&lt;a href=&quot;#Fun&quot; class=&quot;headerlink&quot; title=&quot;Fun&quot;&gt;&lt;/a&gt;Fun&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://danielmiessler.com/blog/dns-servers-you-
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>linux命令执行顺序控制与管道</title>
    <link href="http://yoursite.com/2019/03/01/linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2019/03/01/linux命令执行顺序控制与管道/</id>
    <published>2019-03-01T12:28:02.113Z</published>
    <updated>2019-03-01T13:28:58.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令执行顺序的控制"><a href="#命令执行顺序的控制" class="headerlink" title="命令执行顺序的控制"></a>命令执行顺序的控制</h1><h2 id="顺序执行多条命令"><a href="#顺序执行多条命令" class="headerlink" title="顺序执行多条命令"></a>顺序执行多条命令</h2><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#更新软件源里的软件列表</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install some-tool //这里some-tool是指具体的软件包，例如：banner</span><br><span class="line">$ some-tool</span><br></pre></td></tr></table></figure></p><h2 id="有选择的执行命令"><a href="#有选择的执行命令" class="headerlink" title="有选择的执行命令"></a>有选择的执行命令</h2><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure></p><p>你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。</p><p>上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果：</p><p><img src="https://doc.shiyanlou.com/document-uid1labid63timestamp1544148440172.png/wm" alt=""></p><p>||就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&quot;</span><br></pre></td></tr></table></figure></p><p>流程图：</p><p><img src="https://doc.shiyanlou.com/linux_base/8-3.png/wm" alt=""></p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是什么？管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</p><p>管道又分为匿名管道和具名管道，在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示,具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</p><p>先试用一下管道，比如查看/etc目录下有哪些文件和目录，使用ls命令来查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /etc</span><br></pre></td></tr></table></figure></p><p>有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /etc | less</span><br></pre></td></tr></table></figure></p><p>通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。</p><h2 id="cut-命令，打印每一行的某一字段"><a href="#cut-命令，打印每一行的某一字段" class="headerlink" title="cut 命令，打印每一行的某一字段"></a>cut 命令，打印每一行的某一字段</h2><p>打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut /etc/passwd -d &apos;:&apos; -f 1,6</span><br></pre></td></tr></table></figure></p><p>打印/etc/passwd文件中每一行的前N个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 前五个（包含第五个）</span><br><span class="line">$ cut /etc/passwd -c -5</span><br><span class="line"># 前五个之后的（包含第五个）</span><br><span class="line">$ cut /etc/passwd -c 5-</span><br><span class="line"># 第五个</span><br><span class="line">$ cut /etc/passwd -c 5</span><br><span class="line"># 2到5之间的（包含第五个）</span><br><span class="line">$ cut /etc/passwd -c 2-5</span><br></pre></td></tr></table></figure></p><h2 id="grep-命令，在文本中或-stdin-中查找匹配字符串"><a href="#grep-命令，在文本中或-stdin-中查找匹配字符串" class="headerlink" title="grep 命令，在文本中或 stdin 中查找匹配字符串"></a>grep 命令，在文本中或 stdin 中查找匹配字符串</h2><p>grep命令的一般形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure></p><p>搜索/home/shiyanlou目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rnI &quot;shiyanlou&quot; ~</span><br></pre></td></tr></table></figure></p><ul><li>-r 参数表示递归搜索子目录中的文件</li><li>-n表示打印匹配项行号</li><li>-I表示忽略二进制文件</li></ul><p>当然也可以在匹配字段中使用正则表达式，下面简单的演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看环境变量中以&quot;yanlou&quot;结尾的字符串</span><br><span class="line">$ export | grep &quot;.*yanlou$&quot;</span><br></pre></td></tr></table></figure><ul><li>$表示一行的末尾</li></ul><h2 id="wc-命令，简单小巧的计数工具"><a href="#wc-命令，简单小巧的计数工具" class="headerlink" title="wc 命令，简单小巧的计数工具"></a>wc 命令，简单小巧的计数工具</h2><p>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc /etc/passwd</span><br></pre></td></tr></table></figure></p><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 行数</span><br><span class="line">$ wc -l /etc/passwd</span><br><span class="line"># 单词数</span><br><span class="line">$ wc -w /etc/passwd</span><br><span class="line"># 字节数</span><br><span class="line">$ wc -c /etc/passwd</span><br><span class="line"># 字符数</span><br><span class="line">$ wc -m /etc/passwd</span><br><span class="line"># 最长行字节数</span><br><span class="line">$ wc -L /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="sort-排序命令"><a href="#sort-排序命令" class="headerlink" title="sort 排序命令"></a>sort 排序命令</h2><p>这个命令前面我们也是用过多次，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p><p>默认为字典排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort</span><br></pre></td></tr></table></figure></p><p>反转排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -r</span><br></pre></td></tr></table></figure></p><p>按特定字段排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t&apos;:&apos; -k 3</span><br></pre></td></tr></table></figure></p><ul><li>-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；</li><li>-k 字段号用于指定对哪一个字段进行排序。</li></ul><p>这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n</span><br></pre></td></tr></table></figure></p><h2 id="uniq-去重命令"><a href="#uniq-去重命令" class="headerlink" title="uniq 去重命令"></a>uniq 去重命令</h2><p>uniq命令可以用于过滤或者输出重复行。</p><h3 id="过滤重复行"><a href="#过滤重复行" class="headerlink" title="过滤重复行"></a>过滤重复行</h3><p>我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq</span><br></pre></td></tr></table></figure></p><p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq</span><br><span class="line"># 或者$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u</span><br></pre></td></tr></table></figure></p><p>这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。</p><h3 id="输出重复行"><a href="#输出重复行" class="headerlink" title="输出重复行"></a>输出重复行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 输出重复过的行（重复的只输出一个）及重复次数</span><br><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc</span><br><span class="line"># 输出所有重复的行</span><br><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令执行顺序的控制&quot;&gt;&lt;a href=&quot;#命令执行顺序的控制&quot; class=&quot;headerlink&quot; title=&quot;命令执行顺序的控制&quot;&gt;&lt;/a&gt;命令执行顺序的控制&lt;/h1&gt;&lt;h2 id=&quot;顺序执行多条命令&quot;&gt;&lt;a href=&quot;#顺序执行多条命令&quot; class=&quot;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>HTC VIVE - 1</title>
    <link href="http://yoursite.com/2019/02/28/vive1/"/>
    <id>http://yoursite.com/2019/02/28/vive1/</id>
    <published>2019-02-28T06:40:28.960Z</published>
    <updated>2019-03-03T13:08:34.081Z</updated>
    
    <content type="html"><![CDATA[<p>安装VIVE和SteamVR至少需要占用1020MB的磁盘空间。</p><h2 id="技术规格"><a href="#技术规格" class="headerlink" title="技术规格"></a>技术规格</h2><p>“HTC Vive”具有90赫兹的刷新速率。该设备使用两个屏幕，每眼一个屏幕，每个屏幕具有1080×1200分辨率。</p><p>最低系统要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GPU: NVIDIA GeForce GTX 970 / AMD Radeon R9 290 同等或更高的版本</span><br><span class="line">CPU: Intel i5-4590 / AMD FX-8350 同等或更高的版本</span><br><span class="line">RAM: 4GB+</span><br><span class="line">Video Output: HDMI 1.4 或 DisplayPort 1.2 或更高版本</span><br><span class="line">USB Port: 1x USB 2.0 或更高版本</span><br><span class="line">操作系统: Windows 7 SP1 或更新版本[8]</span><br></pre></td></tr></table></figure></p><h2 id="Viveport-M简介"><a href="#Viveport-M简介" class="headerlink" title="Viveport M简介"></a>Viveport M简介</h2><p>Viveport M是HTC面向移动市场推出的虚拟现实应用商店，适用于Android平台并广泛兼容多种移动VR设备，其内容将以360°视频和体验类游戏为主，旨在为用户提供更多元化、更高品质的移动VR内容与体验。Viveport M将为全球数以万计的开发者提供一个展示内容的新平台，吸引更多开发者和合作伙伴加入到蓬勃发展的Vive生态系统中，接触到全球增长速度最快的用户群体。<br>系统支持：安卓5.0及以上；屏幕尺寸：5-6寸</p><h2 id="手柄"><a href="#手柄" class="headerlink" title="手柄"></a>手柄</h2><p>1 开关、系统菜单按钮：只有这个按钮不可以编程（默认），用来打开手柄，其实没用关的功能。在游戏中按下该按钮是调出系统默认的菜单，用来关闭，切换游戏用的。</p><p>2 menu按钮：默认用来打开游戏菜单。</p><p>3 grip按钮：用的最少的按钮，每个手柄上虽然有两个，但是是相同的。</p><p>4 trigger按钮：扳机按钮，用的最多，可以有力度。</p><p>5 pad：触摸屏+鼠标的功能，可触摸，可点击。</p><h2 id="vive开发"><a href="#vive开发" class="headerlink" title="vive开发"></a>vive开发</h2><p>需要两个插件：</p><p><a href="https://www.assetstore.Unity3D.com/cn/#!/content/32647" target="_blank" rel="noopener">SteamVR Plugin</a></p><p><a href="https://www.assetstore.unity3d.com/cn/#!/content/64219" target="_blank" rel="noopener">Vive Input Utility</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">SteamVR </span><br><span class="line"></span><br><span class="line">这个目录下的脚本都是用来定制SteamVR插件中某些脚本在Unity中的Inspector界面及功能的</span><br><span class="line">——Editor</span><br><span class="line"></span><br><span class="line">    定制SteamVR_Camera.cs这个脚本在Inspector中的显示效果 </span><br><span class="line">    SteamVR_Editor.cs  </span><br><span class="line">    定制SteamVR_RenderModel.cs脚本在Inspector中的功能 </span><br><span class="line">    SteamVR_RenderModelEditor.cs　 </span><br><span class="line">    上面提到的弹出的SteamVR_Settings对话框里面的选项就在这儿定制 </span><br><span class="line">    SteamVR_Settings.cs　　　　　　 </span><br><span class="line">    定制SteamVR_SkyBox.cs在Inspector中显示的属性</span><br><span class="line">    SteamVR_SkyboxEditor.cs　　　　 </span><br><span class="line">    用来检查插件的更新　　 </span><br><span class="line">    SteamVR_Update.cs　　</span><br><span class="line">　　　　　 </span><br><span class="line">这个文件夹下面放着一些工具脚本　　　　　 </span><br><span class="line">——Extras　　　　 </span><br><span class="line"></span><br><span class="line">    这个脚本用来检测物体是否被用户所凝视　　　　</span><br><span class="line">    SteamVR_GazeTracker.cs 　　　　 </span><br><span class="line">    通过手柄指向来产生一条激光束 </span><br><span class="line">    SteamVR_LeaserPointer.cs　　　　</span><br><span class="line">    用来瞬移的脚本 </span><br><span class="line">    SteamVR_Teleporter.cs　　　　　 </span><br><span class="line">    示例场景中扔物体的脚本</span><br><span class="line">    SteamVR_TestThrow.cs　　　　　　</span><br><span class="line">    示例场景中跟踪相机的脚本 </span><br><span class="line">    SteamVR_TestTrackedCamera.cs　 </span><br><span class="line">    控制器(手柄)集成脚本</span><br><span class="line">    SteamVR_trackedController.cs　 </span><br><span class="line"></span><br><span class="line">存放示例demo的材质体　　 </span><br><span class="line">——Materials </span><br><span class="line">存放SteamVR预制体</span><br><span class="line">——Prefabs </span><br><span class="line"></span><br><span class="line">    相机预制体　 </span><br><span class="line">    [CameraRig] </span><br><span class="line">    状态相关的overlay显示预制体　 </span><br><span class="line">    [Status] </span><br><span class="line">    /*SteamVR_Render预制体*/　 </span><br><span class="line">    [SteamVR] </span><br><span class="line"></span><br><span class="line">/*一些自带的shader*/　 </span><br><span class="line">——Scenes</span><br><span class="line">/*SteamVR核心脚本*/　 </span><br><span class="line">——Scripts </span><br><span class="line">    /*SteamVR的封装类*/ </span><br><span class="line">    SteamVR.cs </span><br><span class="line">    /*SteamVR的核心相机类*/ </span><br><span class="line">    SteamVR_Camera.cs </span><br><span class="line">    /*SteamVR相机翻转*/ </span><br><span class="line">    SteamVR_CameraFlip.cs </span><br><span class="line">    /*SteamVR相机网格隐藏*/ </span><br><span class="line">    SteamVR_CameraMask.cs </span><br><span class="line">    /*控制器封装类*/ </span><br><span class="line">    SteamVR_Controller.cs </span><br><span class="line">    /*控制器管理类*/ </span><br><span class="line">    SteamVR_ControllerManager.cs </span><br><span class="line">    /*声音控制类*/ </span><br><span class="line">    SteamVR_Ears.cs </span><br><span class="line">    /*外部相机*/ </span><br><span class="line">    SteamVR_ExternalCamera.cs </span><br><span class="line">    /*场景进行渐显或者渐隐的类*/ </span><br><span class="line">    SteamVR_Fade.cs </span><br><span class="line">    /*跟踪设备的扫描范围*/ </span><br><span class="line">    SteamVR_Frustum.cs </span><br><span class="line">    /*绘制pc上的伴随窗口*/ </span><br><span class="line">    SteamVR_GameView.cs </span><br><span class="line">    /*关节反身运动*/ </span><br><span class="line">    SteamVR_IK.cs </span><br><span class="line">    /*场景切换类*/ </span><br><span class="line">    SteamVR_LoadLevel.cs </span><br><span class="line">    /*菜单类*/ </span><br><span class="line">    SteamVR_Menu.cs </span><br><span class="line">    /*overly封装类*/ </span><br><span class="line">    SteamVR_Overlay.cs </span><br><span class="line">    /*运动区域*/ </span><br><span class="line">    SteamVR_PlayArea.cs </span><br><span class="line">    /*Vive渲染流程控制的核心类*/ </span><br><span class="line">    SteamVR_Render.cs </span><br><span class="line">    /*设置天空盒*/ </span><br><span class="line">    SteamVR_Skybox.cs </span><br><span class="line">    /*做球形投影的类*/ </span><br><span class="line">    SteamVR_SphericalProjection.cs </span><br><span class="line">    /*通过overlay显示统计信息*/ </span><br><span class="line">    SteamVR_Stats.cs </span><br><span class="line">    /*根据不同状态渐变显示不同的信息*/ </span><br><span class="line">    SteamVR_Status.cs </span><br><span class="line">    /*根据不同状态渐变显示不同文本信息*/ </span><br><span class="line">    SteamVR_StatusText.cs </span><br><span class="line">    /*控制器测试脚本*/ </span><br><span class="line">    SteamVR_TestController.cs </span><br><span class="line">    /*头盔上的前置相机*/ </span><br><span class="line">    SteamVR_TrackedCamera.cs </span><br><span class="line">    /*跟踪设备管理类*/ </span><br><span class="line">    SteamVR_TrackedObject.cs </span><br><span class="line">    /*5.x版本以前更新设备位置的脚本*/ </span><br><span class="line">    SteamVR_UpdatePoses.cs </span><br><span class="line">    /*工具类，包括事件系统，Transform等等*/ </span><br><span class="line">    SteamVR_Utils.cs </span><br><span class="line">    </span><br><span class="line">/*常用的纹理*/ </span><br><span class="line">——Textures</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装VIVE和SteamVR至少需要占用1020MB的磁盘空间。&lt;/p&gt;
&lt;h2 id=&quot;技术规格&quot;&gt;&lt;a href=&quot;#技术规格&quot; class=&quot;headerlink&quot; title=&quot;技术规格&quot;&gt;&lt;/a&gt;技术规格&lt;/h2&gt;&lt;p&gt;“HTC Vive”具有90赫兹的刷新速率。
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="VR" scheme="http://yoursite.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>Hololens2</title>
    <link href="http://yoursite.com/2019/02/25/hololens2/"/>
    <id>http://yoursite.com/2019/02/25/hololens2/</id>
    <published>2019-02-25T14:10:28.944Z</published>
    <updated>2019-03-02T13:22:44.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hololens2"><a href="#Hololens2" class="headerlink" title="Hololens2"></a>Hololens2</h1><p>售价3500美元</p><p>具有强大的环境感知能力，和信息展示能力。强大的本地计算能力（HPU2），还可连接云端后台来增强。</p><p>Hololens 2本体的几个亮点：</p><ul><li>FOV * 2；  Hololens 2的FOV大约从30°增加到了52°，同时达到每个视距47像素。</li><li>眼球追踪； 眼球追踪也是一个重头戏，Hololens 2 利用了一个小摄像头实现了这个功能。<br>允许其精确追踪你的两只眼睛，并判断具体的注视点位置。与此同时，设备支持Windows Hello和虹膜识别登录，从而允许多人轻松，快速，安全地共享设备。</li><li>完全的手指跟踪； 基本上实现了Alex承诺的’instinctual control’。</li><li>显示系统: MEMS激光显示器，而且这是当前市场上最小和最高能效的2K显示器。</li></ul><p>除了高通骁龙 850 处理器，HoloLens 2 还内置了 AI 处理单元。因此，它能够直接连接到微软的 Azure 云服务。「这意味着某些 AI 任务会被移交给云计算处理，最终的运算结果将会更加精确——类似一厘米空间映射（spatial mapping）和一毫米空间映射的区别。头显处理这些任务仍需几秒钟时间，Kipman 相信这是企业用户可以接受的延迟时长。」《连线》报道称。早在去年 10 月，微软就已推出 Dynamics 365 Remote Assist 和 Dynamics 365 Layout 两个 app。前者为 MR 头显的使用者提供远程帮助；后者将通过云记住用户创建的虚拟图像，并将它固定在特定的地方，以便多名协作用户查找。</p><p>在北京时间今天凌晨的 MWC 发布会上，微软推出了全新的员工培训应用 Dynamics 365 Guides。「就好像是为现实世界准备的，能一步步引导你的谷歌地图。」CNET 的记者这样形容。Dynamics 365 Guides 的 PC 端应用还能创建交互式内容，包括添加图片和视频，3D 模型等。</p><p>如果将设备连接至全新的Azure Remote Rendering混合现实云端服务，你将可以快速生成复杂的三维数字模型，而原本企业可能需要花费数天或数月的时间才能构建出与之媲美的模型细节。如果没有云端的图形处理能力，这是不可能实现的任务。Azure Remote Rendering可以帮助人们自由体验3D，从而实现更快，更优的决策。微软认为，今天如果要通过移动设备和混合现实头显与高质量3D模型进行交互，你通常需要“抽取”或简化3D模型。但对于设计评审和医疗规划等场景，每个细节都非常重要，而简化asset可能会导致关键决策所需的重要细节丢失。Azure Remote Rendering可以在云端渲染高质量的3D内容，并将其全部实时传输至边缘设备，而且能够确保“每个细节都完好无损”。</p><blockquote><p>如果把未来的公司比作一个厨房，那么云服务大概是水电煤，数据就是基础原料，AI算法服务是不同的菜谱，操作系统则是一台功能齐备的厨师机，目前这厨房里的所有设备微软全都齐备，并且都在为未来布局。</p></blockquote><p>技术规格:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">光学：透视全息透镜（波导）</span><br><span class="line"></span><br><span class="line">分辨率：2k 3：2光引擎</span><br><span class="line"></span><br><span class="line">全息密度：&gt; 2.5k辐射点（每弧度光点）</span><br><span class="line"></span><br><span class="line">注视点渲染：针对3D眼睛位置显示的优化</span><br><span class="line"></span><br><span class="line">深度传感器：Azure Kinect传感器</span><br><span class="line"></span><br><span class="line">IMU：加速度计，陀螺仪，磁力计</span><br><span class="line"></span><br><span class="line">摄像头：800万像素，1080P/30帧视频</span><br><span class="line"></span><br><span class="line">麦克风阵列：5组</span><br><span class="line"></span><br><span class="line">扬声器：内置空间音频</span><br><span class="line"></span><br><span class="line">手部追踪：双手全关节模型，直接操纵</span><br><span class="line"></span><br><span class="line">眼动追踪：实时追踪</span><br><span class="line"></span><br><span class="line">语音 ：板载命令与控制，具有互联网连接的自然语言</span><br><span class="line"></span><br><span class="line">六自由度追踪：世界规模的位置追踪</span><br><span class="line"></span><br><span class="line">空间映射：实时环境网格</span><br><span class="line"></span><br><span class="line">混合现实捕获：混合全息图和物理环境照片和视频</span><br><span class="line"></span><br><span class="line">SoC：高通骁龙850计算平台，不支持4G LTE</span><br><span class="line"></span><br><span class="line">HPU：第二代定制全息处理单元</span><br><span class="line"></span><br><span class="line">WiFi：802.11ac 2×2</span><br><span class="line"></span><br><span class="line">蓝牙：5.0</span><br><span class="line"></span><br><span class="line">USB：USB Type-C</span><br><span class="line"></span><br><span class="line">续航能力：2-3小时的有效使用时间</span><br><span class="line"></span><br><span class="line">充电：USB供电 – 快速充电</span><br><span class="line"></span><br><span class="line">热量：被动冷却</span><br><span class="line"></span><br><span class="line">佩戴：适合眼镜，可使用表盘调节</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.yivian.com/wp-content/uploads/2019/02/cbbf5bbe94ecece41f61acfdb246d2b9.jpg" alt=""></p><h1 id="Azure-Kinect"><a href="#Azure-Kinect" class="headerlink" title="Azure Kinect"></a>Azure Kinect</h1><p>微软同时发布了一款新的Azure Kinect设备，为开发者提供了创建人工智能体验的新方式。Azure Kinect将HoloLens 2中的深度感应摄像头技术与圆形麦克风阵列和彩色摄像头相结合，并搭配以Microsoft Azure中的人工智能服务。它可以帮助开发者建立新的感知功能，如根据锯子的声音识别其是否属于危险的运行情况，支持机器人在装箱时判断距离，或者是识别从商店货架中选择的物品。</p><p><img src="https://pic3.zhimg.com/80/v2-46b5d734136d099176cff8c55d3eda7e_hd.jpg" alt=""></p><p>第四代的Kinect，结合了在边缘运行的AI工具。这种深度和动作感知技术最初是在十年前开发，并旨在为Xbox创建手势识别附件。但对于可以准确感知深度并确定人体在空间中移动的能力，其潜力远远不局限于游戏。例如，Ocuvera正与Azure Kinect合作开发这样一种系统：旨在帮助防止每年在美国医院发生的大约100万次跌倒，甚至是全球范围内的更多跌倒。他们研发的系统可以感知需要帮助行走的患者是于何时无助地下床，并提前预警护士以提供帮助。利用深度感应摄像头和人工智能算法，系统可以在患者起床前识别出运动模式，如坐起或摆动腿部的动作。11个临床试点的初步研究结果发现，在实施上述技术后，无辅助和未留意的下床行走减少了90％以上。首席执行官史蒂夫·凯恩（Steve Kiene）表示，Ocuvera团队调查了世界每一台深度感应摄像头，甚至试图开发自家的深度感应摄像头。但对于区分病人是向前移动抑或只是翻身，没有任何一款设备能够接近于Azure Kinect的准确性和分辨率。他说道：“这就像玩扑克时的认牌一样。只有Azure Kinect能够为我们提供可以真正了解患者在病床上发生的情况，并以足够的准确度预测其意图的数据。当我们在医院进行试点测试时，他们经常告诉我们这是不可能的做到的事情，但随后他们发现它确实有效，而且他们感到非常惊讶。”</p><p>参考文章</p><ol><li><p><a href="https://link.zhihu.com/?target=https%3A//yivian.com/news/57176.html" target="_blank" rel="noopener">售价3500美元，中国首发，微软HoloLens 2正式发布 - 映维网</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//yivian.com/news/57215.html" target="_blank" rel="noopener">十年一剑！微软HoloLens 2是如何沸腾下一代计算平台 - 映维网</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hololens2&quot;&gt;&lt;a href=&quot;#Hololens2&quot; class=&quot;headerlink&quot; title=&quot;Hololens2&quot;&gt;&lt;/a&gt;Hololens2&lt;/h1&gt;&lt;p&gt;售价3500美元&lt;/p&gt;
&lt;p&gt;具有强大的环境感知能力，和信息展示能力。强大的本地计
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="Hololens" scheme="http://yoursite.com/tags/Hololens/"/>
    
  </entry>
  
  <entry>
    <title>linux帮助命令和crontab</title>
    <link href="http://yoursite.com/2019/02/21/linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/02/21/linux帮助命令/</id>
    <published>2019-02-21T14:43:51.057Z</published>
    <updated>2019-02-21T15:24:49.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h2><p>可以用type来区分命令是内建的还是外部的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type + 命令</span><br></pre></td></tr></table></figure></p><ul><li>内建命令是写在bash源码的builtins里面的</li><li>外部命令通常放在/bin，/user/bin,/sbin,/usr/sbin等等</li></ul><h2 id="crontab语法"><a href="#crontab语法" class="headerlink" title="crontab语法"></a>crontab语法</h2><p>用于设置周期性被执行的指令。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p><p>通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell　script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。</p><p>crontab 的格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name command to be executed</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e 表示为当前用户添加计划任务</span><br><span class="line">$ sudo crontab -e 表示为root用户添加计划任务</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内建命令与外部命令&quot;&gt;&lt;a href=&quot;#内建命令与外部命令&quot; class=&quot;headerlink&quot; title=&quot;内建命令与外部命令&quot;&gt;&lt;/a&gt;内建命令与外部命令&lt;/h2&gt;&lt;p&gt;可以用type来区分命令是内建的还是外部的&lt;br&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C# 反射（Reflection）</title>
    <link href="http://yoursite.com/2019/02/21/c%20sharp%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/02/21/c sharp反射/</id>
    <published>2019-02-21T07:21:06.272Z</published>
    <updated>2019-02-23T11:48:35.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射（Reflection）的用途"><a href="#反射（Reflection）的用途" class="headerlink" title="反射（Reflection）的用途"></a>反射（Reflection）的用途</h1><p>反射（Reflection）有下列用途：</p><ul><li>它允许在运行时查看特性（attribute）信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul><h2 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h2><p>使用反射（Reflection）可以查看特性（attribute）信息。</p><p>System.Reflection 类的 MemberInfo 对象需要被初始化，用于发现与类相关的特性（attribute）。为了做到这点，您可以定义目标类的一个对象，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.MemberInfo info = typeof(MyClass);</span><br></pre></td></tr></table></figure></p><p>下面的程序演示了这点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">[AttributeUsage(AttributeTargets.All)]</span><br><span class="line">public class HelpAttribute : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">   public readonly string Url;</span><br><span class="line"></span><br><span class="line">   public string Topic  // Topic 是一个命名（named）参数</span><br><span class="line">   &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">         return topic;</span><br><span class="line">      &#125;</span><br><span class="line">      set</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">         topic = value;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public HelpAttribute(string url)  // url 是一个定位（positional）参数</span><br><span class="line">   &#123;</span><br><span class="line">      this.Url = url;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private string topic;</span><br><span class="line">&#125;</span><br><span class="line">[HelpAttribute(&quot;Information on the class MyClass&quot;)]</span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace AttributeAppl</span><br><span class="line">&#123;</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         System.Reflection.MemberInfo info = typeof(MyClass);</span><br><span class="line">         object[] attributes = info.GetCustomAttributes(true);</span><br><span class="line">         for (int i = 0; i &lt; attributes.Length; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            System.Console.WriteLine(attributes[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会显示附加到类 MyClass 上的自定义特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelpAttribute</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射（Reflection）的用途&quot;&gt;&lt;a href=&quot;#反射（Reflection）的用途&quot; class=&quot;headerlink&quot; title=&quot;反射（Reflection）的用途&quot;&gt;&lt;/a&gt;反射（Reflection）的用途&lt;/h1&gt;&lt;p&gt;反射（Reflect
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="c#" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C# 特性（Attribute）</title>
    <link href="http://yoursite.com/2019/02/21/c%20sharp%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/02/21/c sharp特性/</id>
    <published>2019-02-21T07:06:13.376Z</published>
    <updated>2019-02-23T11:49:19.555Z</updated>
    
    <content type="html"><![CDATA[<p>特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p><p>.Net 框架提供了两种类型的特性：预定义特性和自定义特性。</p><h1 id="预定义特性（Attribute）"><a href="#预定义特性（Attribute）" class="headerlink" title="预定义特性（Attribute）"></a>预定义特性（Attribute）</h1><p>.Net 框架提供了三种预定义特性：</p><ul><li>AttributeUsage</li><li>Conditional</li><li>Obsolete</li></ul><h1 id="创建自定义特性（Attribute）"><a href="#创建自定义特性（Attribute）" class="headerlink" title="创建自定义特性（Attribute）"></a>创建自定义特性（Attribute）</h1><p>创建并使用自定义特性包含四个步骤：</p><ul><li>声明自定义特性</li><li>构建自定义特性</li><li>在目标程序元素上应用自定义特性</li><li>通过反射访问特性</li></ul><h2 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h2><p>一个新的自定义特性应派生自 System.Attribute 类。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们已经声明了一个名为 DeBugInfo 的自定义特性。</p><h2 id="构建自定义特性"><a href="#构建自定义特性" class="headerlink" title="构建自定义特性"></a>构建自定义特性</h2><p>让我们构建一个名为 DeBugInfo 的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息：</p><ul><li>bug 的代码编号</li><li>辨认该 bug 的开发人员名字</li><li>最后一次审查该代码的日期</li><li>一个存储了开发人员标记的字符串消息</li></ul><p>我们的 DeBugInfo 类将带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（property）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，消息将是一个可选的命名（named）参数。</p><p>每个特性必须至少有一个构造函数。必需的定位（ positional）参数应通过构造函数传递。下面的代码演示了 DeBugInfo 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">  private int bugNo;</span><br><span class="line">  private string developer;</span><br><span class="line">  private string lastReview;</span><br><span class="line">  public string message;</span><br><span class="line"></span><br><span class="line">  public DeBugInfo(int bg, string dev, string d)</span><br><span class="line">  &#123;</span><br><span class="line">      this.bugNo = bg;</span><br><span class="line">      this.developer = dev;</span><br><span class="line">      this.lastReview = d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int BugNo</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return bugNo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string Developer</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return developer;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string LastReview</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return lastReview;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string Message</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return message;</span><br><span class="line">      &#125;</span><br><span class="line">      set</span><br><span class="line">      &#123;</span><br><span class="line">          message = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用自定义特性"><a href="#应用自定义特性" class="headerlink" title="应用自定义特性"></a>应用自定义特性</h2><p>通过把特性放置在紧接着它的目标之前，来应用该特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">[DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]</span><br><span class="line">class Rectangle</span><br><span class="line">&#123;</span><br><span class="line">  // 成员变量</span><br><span class="line">  protected double length;</span><br><span class="line">  protected double width;</span><br><span class="line">  public Rectangle(double l, double w)</span><br><span class="line">  &#123;</span><br><span class="line">      length = l;</span><br><span class="line">      width = w;</span><br><span class="line">  &#125;</span><br><span class="line">  [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;,</span><br><span class="line">  Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">  public double GetArea()</span><br><span class="line">  &#123;</span><br><span class="line">      return length * width;</span><br><span class="line">  &#125;</span><br><span class="line">  [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)]</span><br><span class="line">  public void Display()</span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);</span><br><span class="line">      Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);</span><br><span class="line">      Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。&lt;/p&gt;
&lt;p&gt;.Net 框架提供了两种类型的
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="c#" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>牧云集-1</title>
    <link href="http://yoursite.com/2019/02/21/%E7%89%A7%E4%BA%91%E9%9B%86-1/"/>
    <id>http://yoursite.com/2019/02/21/牧云集-1/</id>
    <published>2019-02-21T05:23:44.966Z</published>
    <updated>2019-02-21T05:29:57.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>故事1</p></blockquote><p>新郎，特地和司仪要了话筒，说了一段话，他说他父母婚姻不幸，心里那个自己，从来没有长大过。</p><p>从来我不是不爱你，不是一次次想要推开你。不是心有不忿意难平。这世间，离别太多。 太美好的你，怕握不住。</p><p>嗯，那个戒指，他配了项链挂在胸口。忽然明白，为什么十年，依旧是他们两个。</p><p>或许女孩子从来不卑微，她知道命中注定就是他。</p><p>嗯，我一直看见的婚礼都是新娘哭，新郎笑。</p><p>今天第一次看见新郎哭得双肩耸动，新娘笑着安慰，帮他抹泪。</p><p>很甜！</p><blockquote><p>故事二                                                           </p></blockquote><p>高中时一个同学沉迷网络</p><p>时常半夜翻墙出校上网</p><p>一日他照例翻墙</p><p>翻到一半就拔足狂奔而归</p><p>面色古怪，问之不语</p><p>从此认真读书，不再上网</p><p>学校盛传他见鬼了</p><p>后来他考上名校，我们问起这事</p><p>他沉默良久，说</p><p>“那天父亲来送生活费</p><p>舍不得住旅馆，在墙下坐了一夜”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;故事1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新郎，特地和司仪要了话筒，说了一段话，他说他父母婚姻不幸，心里那个自己，从来没有长大过。&lt;/p&gt;
&lt;p&gt;从来我不是不爱你，不是一次次想要推开你。不是心有不忿意难平。这世间，离别太多。 太美好的你，怕
      
    
    </summary>
    
      <category term="洛书" scheme="http://yoursite.com/categories/%E6%B4%9B%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-1</title>
    <link href="http://yoursite.com/2019/02/16/python1/"/>
    <id>http://yoursite.com/2019/02/16/python1/</id>
    <published>2019-02-15T23:29:13.542Z</published>
    <updated>2019-02-21T13:43:34.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(&apos;please enter your name: &apos;)</span><br><span class="line">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><ol><li><p>Python允许用r’’表示’’内部的字符串默认不转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></li><li><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容, <em><code>...</code>是提示符，不是代码的一部分</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(r&apos;&apos;&apos;hello,</span><br><span class="line">world&apos;&apos;&apos;)</span><br></pre></td></tr></table></figure></li><li><p>一个布尔值只有True、False两种值,布尔值可以用and、or和not运算。  </p></li><li><p>用全部大写的变量名表示常量只是一个习惯上的用法 , eg: PI</p></li><li><p>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure></li></ol><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><ol start="6"><li>Python的整数没有大小限制，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</li></ol><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul><li>美国ASCII编码</li><li>中国GB2312编码</li><li>Unicode统一编码 -&gt; UTF-8编码(可变长编码)</li></ul><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001387245992536e2ba28125cf04f5c8985dbc94a02245e000/0" alt=""></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001387245979827634fd6204f9346a1ae6358d9ed051666000/0" alt=""></p><h2 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h2><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure></p><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b&apos;ABC&apos;</span><br></pre></td></tr></table></figure></p><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure></p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure></p><p>如果bytes中包含无法解码的字节，decode()方法会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte</span><br></pre></td></tr></table></figure></p><p>如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">&apos;中&apos;</span><br></pre></td></tr></table></figure></p><p>要计算str包含多少个字符，可以用len()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>占位符</th><th style="text-align:left">替换内容</th></tr></thead><tbody><tr><td>%d</td><td style="text-align:left">整数</td></tr><tr><td>%f</td><td style="text-align:left">浮点数</td></tr><tr><td>%s</td><td style="text-align:left">字符串</td></tr><tr><td>%x</td><td style="text-align:left">十六进制整数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入与输出&quot;&gt;&lt;a href=&quot;#输入与输出&quot; class=&quot;headerlink&quot; title=&quot;输入与输出&quot;&gt;&lt;/a&gt;输入与输出&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pycharm-basics</title>
    <link href="http://yoursite.com/2019/02/16/pycharm/"/>
    <id>http://yoursite.com/2019/02/16/pycharm/</id>
    <published>2019-02-15T22:53:26.631Z</published>
    <updated>2019-02-23T11:58:08.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的默认快捷键："><a href="#常用的默认快捷键：" class="headerlink" title="常用的默认快捷键："></a>常用的默认快捷键：</h1><p><img src="https://pic3.zhimg.com/80/v2-2c95f7f722a4342d1db875c03ef45daa_hd.jpg" alt=""></p><h1 id="调试栏的几个重要的按钮作用："><a href="#调试栏的几个重要的按钮作用：" class="headerlink" title="调试栏的几个重要的按钮作用："></a>调试栏的几个重要的按钮作用：</h1><p><img src="https://pic4.zhimg.com/80/v2-0353997a0ba329f1211451ef5028ed13_hd.jpg" alt=""></p><p>Resume Program：断点调试后，点击按钮，继续执行程序；</p><p><img src="https://pic4.zhimg.com/80/v2-a8c0d6061d0a68efaf22f680c18385fb_hd.jpg" alt=""></p><p>Step Over ：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和Step Into效果一样的（简而言之，越过子函数，但子函数会执行）；</p><p><img src="https://pic3.zhimg.com/80/v2-7cda50d4e2f7db7b2754f02a2344e432_hd.jpg" alt=""></p><p>Step Into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；</p><p><img src="https://pic2.zhimg.com/80/v2-82ce1dc84514744a8fd46b9226454655_hd.jpg" alt=""></p><p>Step Out ： 当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python报错TypeError: ‘&lt;’ not supported between instances of ‘str’ and ‘int’<br>input()返回的数据类型是str，不能直接和整数进行比较，必须先把str换成整数，使用int()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 n = int(input(&quot;Input a number:&quot;))</span><br><span class="line">2 if n&gt;=100:print(int(n)/10)</span><br><span class="line">3 else:print(int(n)*10)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用的默认快捷键：&quot;&gt;&lt;a href=&quot;#常用的默认快捷键：&quot; class=&quot;headerlink&quot; title=&quot;常用的默认快捷键：&quot;&gt;&lt;/a&gt;常用的默认快捷键：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-2c9
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统操作与磁盘管理</title>
    <link href="http://yoursite.com/2019/02/16/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/16/linux文件系统操作与磁盘管理/</id>
    <published>2019-02-15T16:42:03.451Z</published>
    <updated>2019-02-17T03:57:40.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看磁盘和目录的容量"><a href="#查看磁盘和目录的容量" class="headerlink" title="查看磁盘和目录的容量"></a>查看磁盘和目录的容量</h1><blockquote><p>使用df命令查看磁盘的容量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ df</span><br><span class="line">$ df -h</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用du命令查看目录的容量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 默认同样以 块 的大小展示</span><br><span class="line">$ du</span><br><span class="line"># 加上-h参数，以更易读的方式展示</span><br><span class="line">$ du -h</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数指定查看目录的深度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 只查看1级目录的信息</span><br><span class="line">$ du -h -d 0 ~</span><br><span class="line"># 查看2级</span><br><span class="line">$ du -h -d 1 ~</span><br></pre></td></tr></table></figure></p><p>常用参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。</span><br><span class="line">du -a #同--all 显示目录中所有文件的大小。</span><br><span class="line">du -s #同--summarize 仅显示总计，只列出最后加总的值。</span><br></pre></td></tr></table></figure></p><h1 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h1><blockquote><p>用dd命令从标准输入读入用户的输入到标准输出或者一个文件中：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出到文件</span><br><span class="line">$ dd of=test bs=10 count=1</span><br><span class="line"># 输出到标准输出</span><br><span class="line">$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1</span><br><span class="line"># 注:在打完了这个命令后，继续在终端打字，作为你的输入</span><br></pre></td></tr></table></figure><ul><li>bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。</li></ul><blockquote><p>将输出的英文字符转换为大写再写入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用-dd-命令创建虚拟镜像文件"><a href="#使用-dd-命令创建虚拟镜像文件" class="headerlink" title="使用 dd 命令创建虚拟镜像文件"></a>使用 dd 命令创建虚拟镜像文件</h2><blockquote><p>从/dev/zero设备创建一个容量为 256M 的空文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/zero of=virtual.img bs=1M count=256</span><br><span class="line">$ du -h virtual.img</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"><a href="#使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）" class="headerlink" title="使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"></a>使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）</h2><blockquote><p>$ sudo mkfs.ext4 virtual.img</p></blockquote><h2 id="使用-mount-命令挂载磁盘到目录树"><a href="#使用-mount-命令挂载磁盘到目录树" class="headerlink" title="使用 mount 命令挂载磁盘到目录树"></a>使用 mount 命令挂载磁盘到目录树</h2><ul><li><p>mount命令的一般格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [options] [source] [directory]</span><br></pre></td></tr></table></figure></li><li><p>一些常用操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查看磁盘和目录的容量&quot;&gt;&lt;a href=&quot;#查看磁盘和目录的容量&quot; class=&quot;headerlink&quot; title=&quot;查看磁盘和目录的容量&quot;&gt;&lt;/a&gt;查看磁盘和目录的容量&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用df命令查看磁盘的容量&lt;br&gt;&lt;figure 
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-basics</title>
    <link href="http://yoursite.com/2019/02/16/linux/"/>
    <id>http://yoursite.com/2019/02/16/linux/</id>
    <published>2019-02-15T16:38:14.061Z</published>
    <updated>2019-02-18T05:00:58.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的几个优点："><a href="#Linux的几个优点：" class="headerlink" title="Linux的几个优点："></a>Linux的几个优点：</h2><ol><li>免费</li><li>很多软件原生是在Linux下运行的，庞大的社区支持，生态环境好。</li><li>开源，可被定制，开放，多用户的网络操作系统。</li><li>相对安全稳定</li></ol><p>## </p><ul><li>bin 存放二进制可执行文件(ls,cat,mkdir等) </li><li>boot 存放用于系统引导时使用的各种文件 </li><li>dev 用于存放设备文件 </li><li>etc 存放系统配置文件 </li><li>home 存放所有用户文件的根目录 </li><li>lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 </li><li>mnt 系统管理员安装临时文件系统的安装点 </li><li>opt 额外安装的可选应用程序包所放置的位置 </li><li>proc 虚拟文件系统，存放当前内存的映射 </li><li>root 超级用户目录 </li><li>sbin 存放二进制可执行文件，只有root才能访问 </li><li>tmp 用于存放各种临时文件 </li><li>usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 </li><li>var 用于存放运行时需要改变数据的文件</li></ul><blockquote><p>作者：Java3y<br>链接：<a href="https://www.jianshu.com/p/a182a0be4b8a" target="_blank" rel="noopener">https://www.jianshu.com/p/a182a0be4b8a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux的几个优点：&quot;&gt;&lt;a href=&quot;#Linux的几个优点：&quot; class=&quot;headerlink&quot; title=&quot;Linux的几个优点：&quot;&gt;&lt;/a&gt;Linux的几个优点：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;很多软件原生是在Linux下运行
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux压缩解压工具</title>
    <link href="http://yoursite.com/2019/02/15/linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    <id>http://yoursite.com/2019/02/15/linux压缩解压/</id>
    <published>2019-02-14T16:48:41.114Z</published>
    <updated>2019-02-15T04:18:33.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h1><p>linux常见格式：<code>.zip</code>,<code>.rar</code>,<code>.7z</code>,<code>.tar</code>,<code>.gz</code>,<code>.xz</code>,<code>.bz2</code>,<code>.tar.gz</code>,<code>.tar.xz</code>,<code>tar.bz2</code>,<code>.tar.7z</code></p><h2 id="zip压缩打包程序"><a href="#zip压缩打包程序" class="headerlink" title="zip压缩打包程序"></a>zip压缩打包程序</h2><h3 id="使用zip打包文件夹"><a href="#使用zip打包文件夹" class="headerlink" title="使用zip打包文件夹"></a>使用zip打包文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/shiyanlou</span><br><span class="line">$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop</span><br><span class="line">$ du -h shiyanlou.zip</span><br><span class="line">$ file shiyanlou.zip</span><br></pre></td></tr></table></figure><ul><li>-r 参数表示递归打包包含子目录的全部内容，</li><li>-q 参数表示为安静模式，即不向屏幕输出信息，</li><li>-o，表示输出文件，需在其后紧跟打包输出文件名。</li><li>du ,命令查看打包后文件的大小</li></ul><h3 id="设置压缩级别为9和1（9最大，1最小），重新打包："><a href="#设置压缩级别为9和1（9最大，1最小），重新打包：" class="headerlink" title="设置压缩级别为9和1（9最大，1最小），重新打包："></a>设置压缩级别为9和1（9最大，1最小），重新打包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br><span class="line">$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br></pre></td></tr></table></figure><ul><li>-[1-9] 表示压缩级别，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。</li><li>-x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，<strong>注意：这里只能使用绝对路径，否则不起作用。</strong></li></ul><h3 id="创建加密-zip-包"><a href="#创建加密-zip-包" class="headerlink" title="创建加密 zip 包"></a>创建加密 zip 包</h3><p>使用 -e 参数可以创建加密压缩包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure></p><p><strong>如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题,需要加上 <code>-l</code>参数将<code>LF</code> 转换为 <code>CR+LF</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure></p><h2 id="使用-unzip-命令解压缩-zip-文件"><a href="#使用-unzip-命令解压缩-zip-文件" class="headerlink" title="使用 unzip 命令解压缩 zip 文件"></a>使用 unzip 命令解压缩 zip 文件</h2><p>将 shiyanlou.zip 解压到当前目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip shiyanlou.zip</span><br></pre></td></tr></table></figure></p><p>使用安静模式，将文件解压到指定目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -q shiyanlou.zip -d ziptest</span><br></pre></td></tr></table></figure></p><p>如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -l shiyanlou.zip</span><br></pre></td></tr></table></figure></p><p><strong>通常 Windows 系统上面创建的中文名压缩文件，默认会采用 GBK 编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 中文压缩文件.zip</span><br></pre></td></tr></table></figure></p><h2 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h2><blockquote><p>创建一个 tar 包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/shiyanlou</span><br><span class="line">$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>-c 表示创建一个 tar 包文件</li><li>-f 用于指定创建的文件名</li><li>-v 以可视的的方式输出打包的文件</li></ul><blockquote><p>解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir tardir</span><br><span class="line">$ tar -xf shiyanlou.tar -C tardir</span><br></pre></td></tr></table></figure><blockquote><p>只查看不解包文件 -t 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -tf shiyanlou.tar</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure><blockquote><p>解压 *.tar.gz 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>zip：</p><pre><code>打包 ：zip something.zip something （目录请加 -r 参数）解包：unzip something.zip指定路径：-d 参数</code></pre><p>tar：</p><pre><code>打包：tar -cf something.tar something解包：tar -xf something.tar指定路径：-C 参数</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;压缩文件&quot;&gt;&lt;a href=&quot;#压缩文件&quot; class=&quot;headerlink&quot; title=&quot;压缩文件&quot;&gt;&lt;/a&gt;压缩文件&lt;/h1&gt;&lt;p&gt;linux常见格式：&lt;code&gt;.zip&lt;/code&gt;,&lt;code&gt;.rar&lt;/code&gt;,&lt;code&gt;.7z&lt;/code&gt;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hololens-basics</title>
    <link href="http://yoursite.com/2019/02/14/hololens1/"/>
    <id>http://yoursite.com/2019/02/14/hololens1/</id>
    <published>2019-02-14T03:05:01.249Z</published>
    <updated>2019-02-21T06:01:55.391Z</updated>
    
    <content type="html"><![CDATA[<p>同时按住音量的加减键就可以拍照了，不管是不是有应用在运行。</p><p>录像是30fps的，并且最长录制5分钟</p><p>MRTK(Mixed Reality Toolkit) 是微软为我们提供的混合现实开发工具包，旨在帮助我们加速开发混合现实应用程序。</p><p>Hololens 的 Bloom 手势呼出主菜单的效果，主菜单是跟随你移动并且使终面朝你。这就是广告牌（Billboarding） + 平滑追踪（Tag-Along）的联合实现。</p><h1 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h1><ol><li>所有的3D图形应用都采用笛卡尔积坐标系。</li><li>空间坐标系统以真实世界米为一个单位。</li><li>坐标系采用右手定则，X向右为正，Y向上为正，Z向内为正。</li></ol><h1 id="坐标参考框架"><a href="#坐标参考框架" class="headerlink" title="坐标参考框架"></a>坐标参考框架</h1><p>在全息渲染中，有些影像需要跟随用户头部的移动而移动，有些影像在用户头部移动时需要始终保持在固定的位置上。</p><p>Hololens 为我们提供了两种参考框架，分别是静止参考框架（Stationary frame of reference） 和附加参考框架（Attached frame of reference）。</p><h2 id="附加参考框架"><a href="#附加参考框架" class="headerlink" title="附加参考框架"></a>附加参考框架</h2><p>附加参照框架中，当用户移动或转动头部的时候，内容也会跟着走。当 Hololens 无法获取空间信息时，就只会渲染基于附加参照框架的全息图。例如程序在丢失空间映射时，弹出一个正在扫描空间信息的界面，来帮助用户。</p><h2 id="静止参考框架"><a href="#静止参考框架" class="headerlink" title="静止参考框架"></a>静止参考框架</h2><p>在编写游戏、VR程序时，传统做法是建立一个，绝对世界坐标系（absolute world coordinate system）。在该坐标系中，可以可靠的获取任意两个物体之间的关系，只要不移动物体的位置，它们的相对位置是保持不变的。</p><p>然而在 Hololens 中，动态传感器会随着用户的移动而不断的调整对周围世界的扫描。如果仍然采用一个绝对世界坐标系，随着用户的移动，可能就会导致物体的漂移（drift）。例如假设 Hololens 采用绝对世界坐标系，定义房间左侧角落C1，右侧角落为C2，C1(0,0,0),C2(10,0,0)​<br>C1(0,0,0),C2(10,0,0)​，在C1、C2上分别放置一个全息图，当用户在房间移动时，动态传感器重新扫描，发现 C1 到 C2 的距离只有9.9米，这时 C2(9.9,0,0)​</p><p>C2(9.9,0,0)​ ，C2的变化就会导致 C2上的全息图的位置变化，导致物体漂移。</p><h2 id="空间锚"><a href="#空间锚" class="headerlink" title="空间锚"></a>空间锚</h2><p>Hololens 采用空间锚（spatial anchors）来解决这个问题。Hololens 在用户放置全息图的位置上放置空间锚，每一个锚都有一个坐标系统，当用户移动导致动态传感器重新扫描时，Hololens 根据需要调整每个锚的位置，来确保锚上的全息图停留在现实世界的固定位置。</p><p>Hololens 支持将空间锚持久化保存（Spatial anchor persistence），这样在相同的环境下再次启动程序时可以加载锚，实现全息图的位置记忆功能。</p><p>Hololens 还支持空间锚共享（Spatial anchor sharing），通过将空间锚和周围环境的传感器数据从一个HoloLens 传输到另一个HoloLens。两台设备使用共享的空间锚，使得用户可以在相同位置看到一样的东西。</p><h1 id="SpectatorView"><a href="#SpectatorView" class="headerlink" title="SpectatorView"></a>SpectatorView</h1><p>当我们戴上 Hololens 时，一个没有戴上它的人是无法体验到我们所能体验到的奇迹。 SpectatorView（三方视角）允许其他人通过2D屏幕看到 Hololens 用户在他们的世界里看到的东西。SpectatorView（Preview版）提供一种快速和廉价的途径来录制高清的全息影像，而 SpectatorView Pro 版提供了专业质量记录的全景图。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>关于textmeshpro的错误</p><p><img src="/images/two.png" alt=""></p><p>请将刚刚创建的App文件夹整个删掉，在Unity中，点击菜单栏Window &gt; Package Manager，移除TextMesh Pro，如图所示，然后重新导出解决方案即可。</p><p><img src="/images/three.png" alt=""></p><hr><blockquote><p>作者：Jitwxs<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/yuanlaijike/article/category/8389122" target="_blank" rel="noopener">https://blog.csdn.net/yuanlaijike/article/category/8389122</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同时按住音量的加减键就可以拍照了，不管是不是有应用在运行。&lt;/p&gt;
&lt;p&gt;录像是30fps的，并且最长录制5分钟&lt;/p&gt;
&lt;p&gt;MRTK(Mixed Reality Toolkit) 是微软为我们提供的混合现实开发工具包，旨在帮助我们加速开发混合现实应用程序。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="Hololens" scheme="http://yoursite.com/tags/Hololens/"/>
    
  </entry>
  
  <entry>
    <title>linux环境变量</title>
    <link href="http://yoursite.com/2019/02/14/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/02/14/linux环境变量/</id>
    <published>2019-02-13T16:42:11.752Z</published>
    <updated>2019-02-13T17:53:00.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ declare tmp</span><br></pre></td></tr></table></figure><blockquote><p>使用 declare 命令创建一个变量名为 tmp 的变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $tmp</span><br></pre></td></tr></table></figure><blockquote><p>读取变量的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure><blockquote><p>创建子shell</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export temp</span><br></pre></td></tr></table></figure><blockquote><p>导出变量temp为环境变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit hello_shell.sh</span><br></pre></td></tr></table></figure><blockquote><p>创建一个shell脚本文件，第一行  <code>#!/bin/bash</code> 不能省略</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PATH=$PATH:/home/shiyanlou/mybin</span><br></pre></td></tr></table></figure><blockquote><p>添加环境变量，可以在任意目录执行mybin里面的文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure><blockquote><p>让添加的变量全局有效</p><ul><li><code>&gt;&gt;</code> 表示将标准输出以追加的方式重定向到一个文件中</li><li><code>&gt;</code> 是以覆盖的方式重定向到一个文件中</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .zshrc</span><br></pre></td></tr></table></figure><blockquote><p>让环境变量立即生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset temp</span><br></pre></td></tr></table></figure><blockquote><p>删除一个环境变量</p></blockquote><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><img src="https://doc.shiyanlou.com/linux_base/5-2.png/wm" alt=""></p><h2 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h2><ul><li>用户自定义变量</li><li>Shell本身内建的变量</li><li>从自定义变量导出的环境变量</li></ul><table><thead><tr><th>命 令</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td>set</td><td style="text-align:center">显示 Shell 所有变量，包括其内建环境变量，用户自定义变量及导出的环境变量。</td></tr><tr><td>env</td><td style="text-align:center">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td></tr><tr><td>export</td><td style="text-align:center">显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</td></tr></tbody></table><p>按变量的生存周期来划分，Linux 变量可分为两类：</p><ul><li><p>永久的：需要修改配置文件，变量永久生效；</p></li><li><p>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure><blockquote><p>存放shell变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br></pre></td></tr></table></figure><blockquote><p>存放环境变量</p></blockquote><h1 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h1><p>与搜索相关的命令常用的有 <code>whereis，which，find</code>和 <code>locate</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Share-1</title>
    <link href="http://yoursite.com/2019/02/09/share/"/>
    <id>http://yoursite.com/2019/02/09/share/</id>
    <published>2019-02-09T14:51:47.572Z</published>
    <updated>2019-03-08T12:56:49.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fun"><a href="#Fun" class="headerlink" title="Fun"></a>Fun</h1><ol><li><p><a href="http://gogoame.sumbioun.com/" target="_blank" rel="noopener">字母雨</a></p><p> 感受静谧</p></li><li><p><a href="https://comixify.ii.pw.edu.pl/" target="_blank" rel="noopener">Comixify</a></p><p> 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，效果很棒。</p></li><li><p><a href="https://earth.nullschool.net/#current/wind/surface/level/orthographic=133.20,32.77,320" target="_blank" rel="noopener">earth</a></p><p> a global map of wind, weather, and ocean conditions.</p></li><li><p><a href="https://www.youtube.com/watch?v=RgMzdJR5d_c" target="_blank" rel="noopener">Hololens</a></p><p> Mixed Reality HoloLens Solution for Streamlined Shelf Management.</p></li><li><p><a href="https://www.cnblogs.com/xueweihan/p/5216012.html" target="_blank" rel="noopener">小printf的编程故事</a></p><p> 作者仿照《小王子》中的情节，生动有趣的阐述了小printf从编程小白到专家的成长历程。</p></li></ol><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ol><li><p><a href="http://fetchrss.com/" target="_blank" rel="noopener">FetchRSS</a></p><p> 将任何网页转为 RSS 的工具。</p></li><li><p><a href="https://docs.rsshub.app/" target="_blank" rel="noopener">RSSHub</a></p><p> 直接提供各种 Web 应用的 RSS 供订阅。代码开源，可以自己部署。</p></li><li><p><a href="https://love2.io/" target="_blank" rel="noopener">love2.io</a></p><p> 一个收集开源书籍的网站。</p></li><li><p><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜书</a></p><p> 一个搜索电子书的网站。</p></li><li><p><a href="http://www.itdaan.com/index.html" target="_blank" rel="noopener">开发者知识库</a></p><p> 搜索IT解决方案。</p></li><li><p><a href="https://webdemo.myscript.com/views/diagram/index.html#/edit" target="_blank" rel="noopener">Diagram</a></p><p> 手绘图，然后保存成 PPT 的在线服务。</p></li></ol><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ol><li><p><a href="https://www.deviantart.com/hiphopium/art/Amatical-742039669" target="_blank" rel="noopener">DeviantArt</a></p><p> 是一个为艺术家展示各自作品、并交流讨论而设计的社交网路服务网站，里面的壁纸是真的不错。</p></li><li><p><a href="https://www.bitcraze.io/category/guest-blogger/" target="_blank" rel="noopener">Crazyflie</a></p><p> 对Crazyflie有兴趣可以看看。</p></li><li><p><a href="http://www.ahololens.com/?cat=3" target="_blank" rel="noopener">A Hololens</a></p><p> Hololens的相关资讯。</p></li></ol><h1 id="藏经阁"><a href="#藏经阁" class="headerlink" title="藏经阁"></a>藏经阁</h1><ul><li><p>谁是哪个引起蝴蝶效应的第一个IP包？</p></li><li><p>非常在意用电情况，会用任何方式去省电。有一次问他是为什么，他的回答让我们都泪流满面：让这个宇宙的熵，增加的慢一些。 –极客</p></li><li><p>站在更高一个层次，俯瞰时，很多问题都可以轻易解决。 –思维</p></li></ul><h1 id="藏宝图"><a href="#藏宝图" class="headerlink" title="藏宝图"></a>藏宝图</h1><p> <img src="/images/one.jpg" alt="岁月静好"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fun&quot;&gt;&lt;a href=&quot;#Fun&quot; class=&quot;headerlink&quot; title=&quot;Fun&quot;&gt;&lt;/a&gt;Fun&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://gogoame.sumbioun.com/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdowm语法</title>
    <link href="http://yoursite.com/2019/01/29/Markdown/"/>
    <id>http://yoursite.com/2019/01/29/Markdown/</id>
    <published>2019-01-29T07:37:24.867Z</published>
    <updated>2019-02-12T17:47:46.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><blockquote><p>维基百科</p></blockquote><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 </p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开。</li><li>让你专注于文字而不是排版。</li><li>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</li><li>Markdown 的标记语法有极好的可读性。</li></ol><h2 id="Markdown的简单语法"><a href="#Markdown的简单语法" class="headerlink" title="Markdown的简单语法"></a>Markdown的简单语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题 </span><br><span class="line"></span><br><span class="line">列表</span><br><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br><span class="line"></span><br><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br><span class="line"></span><br><span class="line">插入链接</span><br><span class="line">[简书](http://www.jianshu.com)</span><br><span class="line">插入图片</span><br><span class="line">![](图片链接地址)</span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line">在你希望引用的文字前面加上 &gt;</span><br><span class="line"></span><br><span class="line">斜体</span><br><span class="line">*一盏灯*</span><br><span class="line">粗体</span><br><span class="line">**一简书**</span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/259-dcf737a97e71cd73.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/879" alt=""></p><p>参考文章：<a href="https://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">https://www.jianshu.com/p/q81RER</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Markdow
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Root? Root!</title>
    <link href="http://yoursite.com/2019/01/21/root/"/>
    <id>http://yoursite.com/2019/01/21/root/</id>
    <published>2019-01-21T09:36:53.904Z</published>
    <updated>2019-02-12T17:47:33.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小米手机获取完整ROOT权限"><a href="#小米手机获取完整ROOT权限" class="headerlink" title="小米手机获取完整ROOT权限"></a>小米手机获取完整ROOT权限</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一开始，我只是想删除一些系统自带的软件，以及安装一些需要root权限的app，这里就不细说了，可能我比较爱折腾，也比较想更多地了解一下手机。虽然ROOT一般情况下不会对硬件造成危害，但ROOT后可能会导致系统运行不稳定，耗电大，手机发热，支付有风险的情况。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="一-解锁Bootloader和刷机"><a href="#一-解锁Bootloader和刷机" class="headerlink" title="一 : 解锁Bootloader和刷机"></a>一 : 解锁Bootloader和刷机</h3><ol><li><p>解锁Bootloader申请链接    <a href="http://www.miui.com/unlock/index.html" target="_blank" rel="noopener">http://www.miui.com/unlock/index.html</a><br>小米手机解锁Bootloader教程：<a href="http://www.miui.com/thread-10101861-1-1.html" target="_blank" rel="noopener">http://www.miui.com/thread-10101861-1-1.html</a></p></li><li><p>升级开发版的卡刷/线刷详细教程，以及MIUI ROM最新刷机包下载链接： <a href="http://www.miui.com/shuaji-329.html" target="_blank" rel="noopener">http://www.miui.com/shuaji-329.html</a></p><p><strong>解锁和刷机会清除所有数据，请做好备份！</strong></p><p>MIUI系统备份与恢复的教程：<a href="http://www.miui.com/thread-9605562-1-1.html" target="_blank" rel="noopener">http://www.miui.com/thread-9605562-1-1.html</a></p></li></ol><h3 id="二-：开启ROOT权限"><a href="#二-：开启ROOT权限" class="headerlink" title="二 ：开启ROOT权限"></a>二 ：开启ROOT权限</h3><ol><li>在系统桌面上找到安全中心，并打开。</li><li>点击应用管理—权限—开启ROOT权限。</li><li>然后等待手机重启。</li></ol><p><img src="https://attach.bbs.miui.com/forum/201801/19/004936uaz3d528d2tad7mb.jpg.thumb.jpg" alt=""></p><p>注意：</p><ul><li>稳定版系统不能在授权管理中开启ROOT权限；遇到当前版本撤包，则不能在授权管理中开启ROOT。</li><li>解决方法：您可以在电脑上一键刷入recovery，然后卡刷SU。<br>支持直接获取ROOT权限的版本有开发版,内测版和体验版！</li><li>系统提供的ROOT功能并不是完整的；要获取完整的权限，必须解锁System分区！</li></ul><h3 id="三-：解锁System分区"><a href="#三-：解锁System分区" class="headerlink" title="三 ：解锁System分区"></a>三 ：解锁System分区</h3><p>下载解锁分区软件 <a href="http://www.miui.com/forum.php?mod=attachment&amp;aid=MTY2MDE5NTB8NjVlYzdlYjN8MTU0ODczMzEzMnwwfDEyMjgxMzc5" target="_blank" rel="noopener">Syslock</a>，打开界面中的解锁开关，等待手机重启成功即可生效。</p><p><img src="https://attach.bbs.miui.com/forum/201802/08/113313ikjay777kz7wwanc.jpg.thumb.jpg" alt=""></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>其实手机Root并没有难，重要的是敢于探索的精神，要学会使用好网上的搜索引擎，新世界的大门将会向你打开！</p><blockquote><p>感谢这位大佬 <a href="http://api.bbs.miui.com/thread-12281379-1-1.html" target="_blank" rel="noopener">http://api.bbs.miui.com/thread-12281379-1-1.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;小米手机获取完整ROOT权限&quot;&gt;&lt;a href=&quot;#小米手机获取完整ROOT权限&quot; class=&quot;headerlink&quot; title=&quot;小米手机获取完整ROOT权限&quot;&gt;&lt;/a&gt;小米手机获取完整ROOT权限&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
</feed>
