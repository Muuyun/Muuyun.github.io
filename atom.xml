<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏牧云</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-22T13:42:26.756Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>苏牧云</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>现代诗</title>
    <link href="http://yoursite.com/2019/03/22/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    <id>http://yoursite.com/2019/03/22/现代诗/</id>
    <published>2019-03-22T13:41:35.826Z</published>
    <updated>2019-03-22T13:42:26.756Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1．《再别康桥》（徐志摩）</strong></p><p><strong>轻轻的我走了，</strong></p><p><strong>正如我轻轻的来；</strong></p><p><strong>我轻轻的招手，</strong></p><p><strong>作别西天的云彩。</strong></p><p><strong>那河畔的金柳，</strong></p><p><strong>是夕阳中的新娘；</strong></p><p><strong>波光里的艳影，</strong></p><p><strong>在我的心头荡漾。</strong></p><p><strong>软泥上的青荇，</strong></p><p><strong>油油的在水底招摇；</strong></p><p><strong>在康河的柔波里，</strong></p><p><strong>我甘心做一条水草！</strong></p><p><strong>那榆荫下的一潭，</strong></p><p><strong>不是清泉，是天上虹</strong></p><p><strong>揉碎在浮藻间，</strong></p><p><strong>沉淀着彩虹似的梦。</strong></p><p><strong>寻梦？撑一支长蒿，</strong></p><p><strong>向青草更青处漫溯，</strong></p><p><strong>满载一船星辉，</strong></p><p><strong>在星辉斑斓里放歌。</strong></p><p><strong>但我不能放歌，</strong></p><p><strong>悄悄是别离的笙箫；</strong></p><p><strong>夏虫也为我沉默，</strong></p><p><strong>沉默是今晚的康桥！</strong></p><p><strong>悄悄的我走了，</strong></p><p><strong>正如我悄悄的来；</strong></p><p><strong>我挥一挥衣袖，</strong></p><p><strong>不带走一片云彩。</strong></p><p>这首诗创作于1928年11月，是徐志摩的代表作，也是新月诗派最具代表性的作品。</p><p>康桥，即为英国著名的剑桥大学所在地。几年前，徐志摩曾游学于此，这是诗人一生中重要的转折点，是诗情激荡的岁月，他曾满怀深情地说，“我的眼是康桥教我睁的，我的求知欲是康桥给我拨动的，我的自我意识是康桥给我胚胎的。”</p><p>喜欢这首《再别康桥》已经很久了，久到还是刚上高中的时候，在晨光洒射的去路，在夕阳斜照的归途，边走边在心里默默地背这首诗。</p><p>然后，一切都会因为这份诗情而变得美好。看着路旁的柳树，就想到了夕阳中的新娘；望着西天的云彩，也欲挥一挥衣袖；遇到星月辉映的夜晚，便思索谁会吹起别离的笙箫。</p><p>这首诗以虚实结合的手法描摹了如画的风景，展现了如水的柔情，应该说每一句每一段都完美得无懈可击，但我还是最爱这段——悄悄是别离的笙箫，夏虫也为我沉默，沉默是今晚的康桥。</p><p><strong>引申阅读：《沙扬娜拉》（徐志摩）最是那一低头的温柔，像一朵水莲花不胜凉风的娇羞。道一声珍重，道一声珍重。那一声珍重里有蜜甜的忧愁——沙扬娜拉。</strong></p><p><strong>2．《雨巷》（戴望舒）</strong></p><p><strong>撑着油纸伞，独自</strong></p><p><strong>彷徨在悠长，悠长</strong></p><p><strong>又寂寥的雨巷</strong></p><p><strong>我希望逢着</strong></p><p><strong>一个丁香一样地</strong></p><p><strong>结着愁怨的姑娘。</strong></p><p><strong>她是有</strong></p><p><strong>丁香一样的颜色，</strong></p><p><strong>丁香一样的芬芳</strong></p><p><strong>丁香一样的忧愁，</strong></p><p><strong>在雨中哀怨，</strong></p><p><strong>哀怨又彷徨。</strong></p><p><strong>她彷徨在这寂寥的雨巷，</strong></p><p><strong>撑着油纸伞</strong></p><p><strong>像我一样，</strong></p><p><strong>像我一样地</strong></p><p><strong>默默彳亍着</strong></p><p><strong>冷漠，凄清，又惆怅。</strong></p><p><strong>她静默地走近</strong></p><p><strong>走近，又投出</strong></p><p><strong>太息一般的眼光，</strong></p><p><strong>她飘过</strong></p><p><strong>像梦一般地，</strong></p><p><strong>像梦一般地凄婉迷茫</strong></p><p><strong>像梦中飘过</strong></p><p><strong>一枝丁香地，</strong></p><p><strong>我身旁飘过这女郎；</strong></p><p><strong>她静默地远了，远了，</strong></p><p><strong>到了颓圮的篱墙，</strong></p><p><strong>走尽这雨巷</strong></p><p><strong>在雨的哀曲里，</strong></p><p><strong>消了她的颜色，</strong></p><p><strong>散了她的芬芳，</strong></p><p><strong>消散了，甚至她的</strong></p><p><strong>太息般的眼光，</strong></p><p><strong>丁香般的惆怅。</strong></p><p><strong>撑着油纸伞，独自</strong></p><p><strong>彷徨在悠长，悠长</strong></p><p><strong>又寂寥的雨巷，</strong></p><p><strong>我希望飘过</strong></p><p><strong>一个丁香一样地</strong></p><p><strong>结着愁怨的姑娘。</strong></p><p>这首诗创作于1927年，是戴望舒的成名作。诗中通过一位独自行走结着愁怨的丁香般的姑娘，来抒发作者自己对于人生的迷惘与感伤。</p><p>每次读《雨巷》的时候，我的脑海里总会有层出不穷的画面感。</p><p>那是怎样的雨？是“无边丝雨细如愁”吗？</p><p>那是怎样的巷子？有“淡烟流水画屏幽”吗？</p><p>那又是什么样的姑娘？会“拣尽寒枝不肯栖”吗？</p><p>然而，她就那样撑着油纸伞，慢慢地走着，我们不知道她从哪里来，到哪里去。她好似从画中走来，又走成了一幅画。</p><p>曾经我并不是很喜欢雨，但某年自江南归来，从此爱上雨天，所以我也迷恋这首诗里悠长悠长的雨巷，有诗一般的梦幻，有梦一般的缥缈。</p><p>其实若说戴望舒笔下我最喜欢的一首诗，倒并非这首《雨巷》，只是因为它太有名，当然也很美，所以选了它。相对来说我更倾心于另一首《烦忧》，是较短的回文诗，读来极隽永。</p><p><strong>引申阅读：《烦忧》（戴望舒）说是寂寞的秋的清愁，说是辽远的海的相思，假如有人问我的烦忧，我不敢说出你的名字。我不敢说出你的名字，假如有人问我的烦忧。说是辽远的海的相思，说是寂寞的秋的清愁。</strong></p><p><strong>3．《门前》（顾城）</strong></p><p><strong>我多么希望，有一个门口</strong></p><p><strong>早晨，阳光照在草上</strong></p><p><strong>我们站着</strong></p><p><strong>扶着自己的门扇</strong></p><p><strong>门很低，但太阳是明亮的</strong></p><p><strong>草在结它的种子</strong></p><p><strong>风在摇它的叶子</strong></p><p><strong>我们站着，不说话</strong></p><p><strong>就十分美好</strong></p><p><strong>有门，不用开开</strong></p><p><strong>是我们的，就十分美好</strong></p><p><strong>早晨，黑夜还要流浪</strong></p><p><strong>我们把六弦琴交给他</strong></p><p><strong>我们不走了</strong></p><p><strong>我们需要土地</strong></p><p><strong>需要永不毁灭的土地</strong></p><p><strong>我们要乘着它</strong></p><p><strong>度过一生</strong></p><p><strong>土地是粗糙的，有时狭隘</strong></p><p><strong>然而，它有历史</strong></p><p><strong>有一份天空，一份月亮</strong></p><p><strong>一份露水和早晨</strong></p><p><strong>我们爱土地</strong></p><p><strong>我们站着</strong></p><p><strong>用木鞋挖着泥土</strong></p><p><strong>门也晒热了</strong></p><p><strong>我们轻轻靠着，十分美好</strong></p><p><strong>墙后的草</strong></p><p><strong>不会再长大了</strong></p><p><strong>它只用指尖，触了触阳光</strong></p><p>这首诗创作于1982年8月，作者顾城是朦胧派的重要代表诗人。</p><p>顾城最有名的句子莫过于《一代人》里那句——黑夜给了我黑色的眼睛，我却用它寻找光明。</p><p>不过，读了几首顾城的诗，我最爱的却是这一句，“草在结它的种子，风在摇它的叶子，我们站着，不说话，就十分美好。”</p><p>也正是因为这个句子，我才选了这首《门前》作为推荐。</p><p>而让我欣慰的是，诗中没有华丽词藻的堆砌，也没有遵循什么韵律或节奏，全然是一派自然的纯净，带着和煦的温暖。</p><p>无论土地，阳光，月亮，还是露水；无论草的种子，树的叶子，还是相对而站不说话的人儿，都那般安然美好，自在满足。</p><p>多么希望尘世间也如这首诗一样，我了解你的心意，你知晓我的心绪，我们只是静静地站着，什么都不说，美妙的感觉已经笼罩了你我。</p><p><strong>引申阅读：《远和近》（顾城）你，一会看我，一会看云。我觉得，你看我时很远，你看云时很近。</strong></p><p><strong>4．《断章》（卞之琳）</strong></p><p><strong>你站在桥上看风景，</strong></p><p><strong>看风景人在楼上看你。</strong></p><p><strong>明月装饰了你的窗子，</strong></p><p><strong>你装饰了别人的梦</strong></p><p>这首诗创作于1935年10月，是新月派诗人卞之琳的代表作。</p><p>据作者自述，此诗原是一首长诗中的四句，但整首诗也只有这四句令诗人满意，所以便把它们抽取出来独立成章，因此标题为“断章”。</p><p>看到这种说法，我简直忍不住要为作者鼓掌，一首拖沓勉强的长诗远没有如此小巧精致的短诗让人印象深刻，这般取舍实在是明智。</p><p>可以说这是一首充满哲理的诗作，既有思辨的意味，也有爱的哲理。</p><p>桥上人恋着美好的风景，而楼上人则关注着看风景的人。这是实写，写出了一幅悄然凝视的画面。</p><p>然而夜深人静之际，想必明月一定在她的窗前，而她则成了他渴望的梦。</p><p>此外，再也没有多余的表达了，在戛然而止的结束里，那份隐忍不发的感情显得意味深长。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1．《再别康桥》（徐志摩）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轻轻的我走了，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正如我轻轻的来；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我轻轻的招手，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="洛书" scheme="http://yoursite.com/categories/%E6%B4%9B%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux进程概念</title>
    <link href="http://yoursite.com/2019/03/22/linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/03/22/linux进程概念/</id>
    <published>2019-03-22T11:52:06.574Z</published>
    <updated>2019-03-22T13:33:42.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h3><p><strong>程序</strong>（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指令，帮我们达成某个结果。就如我们去餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，最后我们得到了这么一盘牛肉盖浇饭。它需要去执行，不然它就像一本武功秘籍，放在那里等人翻看。</p><p><strong>进程</strong>（process）：进程是程序在一个数据集合上的一次执行过程。就如我们去了餐馆，给服务员说我要牛肉盖浇饭，她执行了做牛肉盖浇饭这么一个程序，而里面做饭的是一个进程，做牛肉汤汁的是一个进程，把牛肉汤汁与饭混合在一起的是一个进程，把饭端上桌的是一个进程。它就像是我们在看武功秘籍这么一个过程，然后一个篇章一个篇章地去练。</p><blockquote><p><strong>并发：</strong>在一个时间段内，宏观来看有多个程序都在活动，有条不紊的执行（每一瞬间只有一个在执行，只是在一段时间有多个程序都执行过）</p></blockquote><blockquote><p><strong>并行：</strong>在每一个瞬间，都有多个程序都在同时执行，这个必须有多个 CPU 才行</p></blockquote><p>引入进程是因为传统意义上的程序已经不足以描述 OS  中各种活动之间的动态性、并发性、独立性还有相互制约性。程序就像一个公司，只是一些证书，文件的堆积（静态实体）。而当公司运作起来就有各个部门的区分，财务部，技术部，销售部等等，就像各个进程，各个部门之间可以独立运做，也可以有交互（独立性、并发性）。</p><p>而随着程序的发展越做越大，又会继续细分，从而引入了线程的概念，当代多数操作系统、Linux 2.6及更新的版本中，进程本身不是基本运行单位，而是线程的容器。就像上述所说的，每个部门又会细分为各个工作小组（线程），而工作小组需要的资源需要向上级（进程）申请。</p><p><strong>线程</strong>（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。因为线程中几乎不包含系统资源，所以执行更快、更有效率。</p><p><em>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</em></p><h3 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h3><ol><li>以进程的功能与服务的对象来分；</li><li>以应用程序的服务类型来分；</li></ol><p>第一个角度来看，我们可以分为用户进程与系统进程：</p><ul><li>用户进程：通过执行用户程序、应用程序或称之为内核之外的系统程序而产生的进程，此类进程可以在用户的控制下运行或关闭。</li><li>系统进程：通过执行系统内核程序而产生的进程，比如可以执行内存资源分配和进程切换等相对底层的工作；而且该进程的运行不受用户的干预，即使是 root 用户也不能干预系统进程的运行。</li></ul><p>第二角度来看，我们可以将进程分为交互进程、批处理进程、守护进程</p><ul><li>交互进程：由一个 shell 终端启动的进程，在执行过程中，需要与用户进行交互操作，可以运行于前台，也可以运行在后台。</li><li>批处理进程：该进程是一个进程集合，负责按顺序启动其他的进程。</li><li>守护进程：守护进程是一直运行的一种进程，在 Linux  系统启动时启动，在系统关闭时终止。它们独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。例如 httpd  进程，一直处于运行状态，等待用户的访问。还有经常用的 cron（在 centOS 系列为 crond）进程，这个进程为 crontab  的守护进程，可以周期性的执行用户设定的某些任务。</li></ul><h3 id="进程的衍生"><a href="#进程的衍生" class="headerlink" title="进程的衍生"></a>进程的衍生</h3><blockquote><p><strong>fork-exec</strong>是由 Dennis M. Ritchie 创造的</p></blockquote><blockquote><p><strong>fork()</strong> 是一个系统调用（system call），它的主要作用就是为当前的进程创建一个新的进程，这个新的进程就是它的子进程，这个子进程除了父进程的返回值和 PID 以外其他的都一模一样，如进程的执行代码段，内存信息，文件描述，寄存器状态等等</p></blockquote><blockquote><p><strong>exec()</strong> 也是系统调用，作用是切换子进程中的执行程序也就是替换其从父进程复制过来的代码段与数据段</p></blockquote><p> 在将要结束时的子进程代码执行部分已经结束执行了，系统的资源也基本归还给系统了，但若是其进程的进程控制块（PCB）仍驻留在内存中，而它的 PCB 还在，代表这个进程还存在（因为 PCB 就是进程存在的唯一标志，里面有 PID 等消息），并没有消亡，这样的进程称之为僵尸进程（Zombie）。</p><p> 虽然僵尸进程是已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，在进程列表中保留一个位置，记载该进程的退出状态等信息供其父进程收集，从而释放它。但是  Linux 系统中能使用的 PID 是有限的，如果系统中存在有大量的僵尸进程，系统将会因为没有可用的 PID 从而导致不能产生新的进程。</p><p> 另外如果父进程结束（非正常的结束），未能及时收回子进程，子进程仍在运行，这样的子进程称之为孤儿进程。在  Linux 系统中，孤儿进程一般会被 init 进程所“收养”，成为 init 的子进程。由 init  来做善后处理，所以它并不至于像僵尸进程那样无人问津，不管不顾，大量存在会有危害。</p><p> 进程 0 是系统引导时创建的一个特殊进程，也称之为内核初始化，其最后一个动作就是调用 <code>fork()</code> 创建出一个子进程运行 <code>/sbin/init</code>  可执行文件,而该进程就是 PID=1 的进程 1，而进程 0 就转为交换进程（也被称为空闲进程），进程 1 （init  进程）是第一个用户态的进程，再由它不断调用 fork()  来创建系统里其他的进程，所以它是所有进程的父进程或者祖先进程。同时它是一个守护程序，直到计算机关机才会停止。</p><p>我们还可以使用这样一个命令来看，其中 pid 就是该进程的一个唯一编号，ppid 就是该进程的父进程的 pid，command 表示的是该进程通过执行什么样的命令或者脚本而产生的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps －fxo user,ppid,pid,pgid,command</span><br></pre></td></tr></table></figure><h3 id="进程组与Sessions"><a href="#进程组与Sessions" class="headerlink" title="进程组与Sessions"></a>进程组与Sessions</h3><p>每一个进程都会是一个进程组的成员，而且这个进程组是唯一存在的，他们是依靠 PGID（process group ID）来区别的，而每当一个进程被创建的时候，它便会成为其父进程所在组中的一员。</p><p>一般情况，进程组的 PGID 等同于进程组的第一个成员的 PID，并且这样的进程称为该进程组的领导者,也就是领导进程，进程一般通过使用 <code>getpgrp()</code> 系统调用来寻找其所在组的 PGID，领导进程可以先终结，此时进程组依然存在，并持有相同的PGID，直到进程组中最后一个进程终结。</p><p>与进程组类似，每当一个进程被创建的时候，它便会成为其父进程所在 Session 中的一员，每一个进程组都会在一个 Session 中，并且这个 Session 是唯一存在的，</p><p>Session  主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control  terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个  job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。</p><blockquote><p><strong>前台</strong>（foreground）就是在终端中运行，能与你有交互的</p></blockquote><blockquote><p><strong>后台</strong>（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</p></blockquote><p>详细版：<a href="https://segmentfault.com/a/1190000009152815" target="_blank" rel="noopener">Linux session和进程组概述</a></p><h3 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h3><ul><li>我们可以通过 <code>&amp;</code> 这个符号，让我们的命令在后台中运行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &amp;</span><br></pre></td></tr></table></figure><ul><li>被停止并放置在后台的工作我们可以使用这个命令来查看</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure><ul><li>我们可以通过这样的一个命令将后台的工作拿到前台来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#后面不加参数提取预设工作，加参数提取指定工作的编号</span><br><span class="line">#ubuntu 在 zsh 中需要 %，在 bash 中不需要 %</span><br><span class="line">fg [%jobnumber]</span><br></pre></td></tr></table></figure><ul><li>之前我们通过 <code>ctrl + z</code> 使得工作停止放置在后台，若是我们想让其在后台运作我们就使用这样一个命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#与fg类似，加参则指定，不加参则取预设</span><br><span class="line">bg [%jobnumber]</span><br></pre></td></tr></table></figure><ul><li>既然有方法将被放置在后台的工作提至前台或者让它从停止变成继续运行在后台，当然也有方法删除一个工作，或者重启等等</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#kill的使用格式如下</span><br><span class="line">kill -signal %jobnumber</span><br><span class="line"></span><br><span class="line">#signal从1-64个信号值可以选择，可以这样查看</span><br><span class="line">kill －l</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程与程序&quot;&gt;&lt;a href=&quot;#进程与程序&quot; class=&quot;headerlink&quot; title=&quot;进程与程序&quot;&gt;&lt;/a&gt;进程与程序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;程序&lt;/strong&gt;（procedure）：不太精确地说，程序就是执行一系列有逻辑、有顺序结构的指
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux软件安装</title>
    <link href="http://yoursite.com/2019/03/22/linux%E4%B8%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/22/linux下软件安装/</id>
    <published>2019-03-22T11:12:49.718Z</published>
    <updated>2019-03-22T13:34:22.323Z</updated>
    
    <content type="html"><![CDATA[<p>通常 Linux 上的软件安装主要有四种方式：</p><ul><li>在线安装</li><li>从磁盘安装deb软件包</li><li>从二进制软件包安装</li><li>从源代码编译安装</li></ul><p><em>如果你在安装一个软件之后，无法立即使用<code>Tab</code>键补全这个命令，你可以尝试先执行<code>source ~/.zshrc</code>，然后你就可以使用补全操作。</em></p><h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><p><code>apt-get</code> 是用于处理 <code>apt</code>包的公用程序集，我们可以用它来在线安装、卸载和升级软件包等，下面列出一些<code>apt-get</code>包含的常用的一些工具：</p><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td><code>install</code></td><td>其后加上软件包名，用于安装一个软件包</td></tr><tr><td><code>update</code></td><td>从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表</td></tr><tr><td><code>upgrade</code></td><td>升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次<code>update</code></td></tr><tr><td><code>dist-upgrade</code></td><td>解决依赖关系并升级(存在一定危险性)</td></tr><tr><td><code>remove</code></td><td>移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件</td></tr><tr><td><code>autoremove</code></td><td>移除之前被其他软件包依赖，但现在不再被使用的软件包</td></tr><tr><td><code>purge</code></td><td>与remove相同，但会完全移除软件包，包含其配置文件</td></tr><tr><td><code>clean</code></td><td>移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/</td></tr><tr><td><code>autoclean</code></td><td>移除已安装的软件的旧版本软件包</td></tr></tbody></table><p>下面是一些<code>apt-get</code>常用的参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用</td></tr><tr><td><code>-s</code></td><td>模拟安装</td></tr><tr><td><code>-q</code></td><td>静默安装方式，指定多个<code>q</code>或者<code>-q=#</code>,#表示数字，用于设定静默级别，这在你不想要在安装软件包时屏幕输出过多时很有用</td></tr><tr><td><code>-f</code></td><td>修复损坏的依赖关系</td></tr><tr><td><code>-d</code></td><td>只下载不安装</td></tr><tr><td><code>--reinstall</code></td><td>重新安装已经安装但可能存在问题的软件包</td></tr><tr><td><code>--install-suggests</code></td><td>同时安装APT给出的建议安装的软件包</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 更新软件源</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"># 升级没有依赖问题的软件包</span><br><span class="line">$ sudo apt-get upgrade</span><br><span class="line"># 升级并解决依赖关系</span><br><span class="line">$ sudo apt-get dist-upgrade</span><br><span class="line">#搜索软件仓库里面有没有该软件</span><br><span class="line">sudo apt-cache search softname1 softname2 softname3……</span><br></pre></td></tr></table></figure><h3 id="使用dpkg从本地磁盘安装deb软件包"><a href="#使用dpkg从本地磁盘安装deb软件包" class="headerlink" title="使用dpkg从本地磁盘安装deb软件包"></a>使用dpkg从本地磁盘安装deb软件包</h3><p>我们经常可以在网络上见到以<code>deb</code>形式打包的软件包，就需要使用<code>dpkg</code>命令来安装。</p><p><code>dpkg</code>常用参数介绍：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>安装指定deb包</td></tr><tr><td><code>-R</code></td><td>后面加上目录名，用于安装该目录下的所有deb安装包</td></tr><tr><td><code>-r</code></td><td>remove，移除某个已安装的软件包</td></tr><tr><td><code>-I</code></td><td>显示<code>deb</code>包文件的信息</td></tr><tr><td><code>-s</code></td><td>显示已安装软件的信息</td></tr><tr><td><code>-S</code></td><td>搜索已安装的软件包</td></tr><tr><td><code>-L</code></td><td>显示已安装软件包的目录信息</td></tr></tbody></table><p>使用<code>dpkg -L</code>查看<code>deb</code>包目录信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -L emacs24</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常 Linux 上的软件安装主要有四种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在线安装&lt;/li&gt;
&lt;li&gt;从磁盘安装deb软件包&lt;/li&gt;
&lt;li&gt;从二进制软件包安装&lt;/li&gt;
&lt;li&gt;从源代码编译安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;如果你在安装一个软件之后，无法立即使用
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>登天的感觉</title>
    <link href="http://yoursite.com/2019/03/16/%E7%99%BB%E5%A4%A9%E7%9A%84%E6%84%9F%E8%A7%89/"/>
    <id>http://yoursite.com/2019/03/16/登天的感觉/</id>
    <published>2019-03-16T10:45:05.094Z</published>
    <updated>2019-03-16T11:33:31.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="登天的感觉"><a href="#登天的感觉" class="headerlink" title="登天的感觉"></a>登天的感觉</h2><p>上个星期看完了岳晓东的《登天的感觉》，发现心理学其实挺有趣的。为什么我要看这本书呢？因为前个星期张雪峰老师来我们学校，给我们开了场讲座，听他的讲座真的挺有意思的，其实我不想考研，只是抱着听相声的想法去的。期间，张雪峰提到了他最近在看的书，就包括《登天的感觉》，于是我就去图书馆借来看看了。</p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>“我恨我自己，我实在太愚蠢了”，“我们的爱情还有救吗？”……这些日常生活中随处可见的不起眼问题，却妨碍着我们对幸福的追求。在处理这些心理案例的过程中，作者展现了心理咨询的神奇技巧――原来一个人的人生道路可能因为几句话而改变！日常生活中的大多数问题实际都是心理问题，人生的幸福来自于内心的平静，天堂原本就存在于每个人的心中。本书将带给认真的读者飞翔在云端船的美妙享受――登天的感觉。</p><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>读完这本书，给我的收获很大，我有时会思考，如果一个人从小就开始接受心理咨询的帮助，不说永远，只说到20岁就好了，那么这个人的人生，我相信，他的人生将风雨无阻，乘风破浪，他的人生也将是自信，灿烂的人生。所以我认为其实每个人都应该学点心理学，让自己变得更会说话，也让自己的心态变得更好，利人又利己。</p><p>接下来谈谈我从书中get到的点：</p><h4 id="我是哈佛最自卑的人（现实疗法）"><a href="#我是哈佛最自卑的人（现实疗法）" class="headerlink" title="我是哈佛最自卑的人（现实疗法）"></a>我是哈佛最自卑的人（现实疗法）</h4><ul><li>宣泄不良情绪</li><li>强化平常感，自我披露</li><li>人越是在比自己成熟或地位高的人面前获得尊重，就越容易消除个人的自卑感</li><li>转移比较对象</li><li>采取具体行动</li></ul><h4 id="我想从哈佛转学（格式塔疗法）"><a href="#我想从哈佛转学（格式塔疗法）" class="headerlink" title="我想从哈佛转学（格式塔疗法）"></a>我想从哈佛转学（格式塔疗法）</h4><ul><li>过去的事情是忘不掉的</li><li>做心理咨询，好似在耍阴阳平衡（心理平衡）的魔术</li></ul><h4 id="我不要上哈佛大学法学院（来询者中心疗法）"><a href="#我不要上哈佛大学法学院（来询者中心疗法）" class="headerlink" title="我不要上哈佛大学法学院（来询者中心疗法）"></a>我不要上哈佛大学法学院（来询者中心疗法）</h4><ul><li>你不尊重他人，他人怎么可能尊重你</li><li>比较利弊</li><li>角色扮演</li></ul><h4 id="问你是否爱我（理性情绪疗法）"><a href="#问你是否爱我（理性情绪疗法）" class="headerlink" title="问你是否爱我（理性情绪疗法）"></a>问你是否爱我（理性情绪疗法）</h4><ul><li>完美主义与自我中心</li><li>提问与反问</li><li>助人自助</li></ul><h4 id="我们的缘分尽了吗（交互分析疗法）"><a href="#我们的缘分尽了吗（交互分析疗法）" class="headerlink" title="我们的缘分尽了吗（交互分析疗法）"></a>我们的缘分尽了吗（交互分析疗法）</h4><ul><li>考虑得失</li><li>依赖心理 - 老是为自己的行为辩护</li></ul><h4 id="走出心灵创伤的深渊（行为疗法）"><a href="#走出心灵创伤的深渊（行为疗法）" class="headerlink" title="走出心灵创伤的深渊（行为疗法）"></a>走出心灵创伤的深渊（行为疗法）</h4><ul><li>封锁自我 - 防卫方式</li><li>心理健康的人总是幸福的</li></ul><p>以上是我从书中get到的点，算是做一个读书笔记吧，虽然写得很草率，不过反正也没人会看到的，哈哈。</p><h2 id="之前学到的心理小知识"><a href="#之前学到的心理小知识" class="headerlink" title="之前学到的心理小知识"></a>之前学到的心理小知识</h2><p>当我感到萎靡不振的时候可以调整一下肢体动作。</p><p>通过脚步间距来判断兴趣感。</p><p>要让朋友回答的更多，就要盯着他们的眼睛。</p><p>可以先让人帮小忙，再让人帮大忙。</p><p>不知道回应什么时，试着重复对方的话。“你为什么问这个问题?”把问题抛给对方。</p><p>导播主要负责群众的热线和信息接入和切断，提醒主播即时插播广告。</p><p><strong>1.      用【我选择，我负责】，代替【我恐惧、我逃避】</strong></p><p><strong>2.      用【把比赛当成练习】，代替【等练好了再参赛】</strong></p><p><strong>3.      用【高配版的自己】，代替【低配版的自己】</strong></p><p><strong>4.      用【往前走走看】，代替【站在原地纠结】</strong></p><p><strong>5.      用【我帮你解决问题】，代替【我替你打工卖命】</strong></p><p><strong>6.      用【温柔的坚持】，代替【激烈的反抗】</strong></p><h2 id="心理小游戏"><a href="#心理小游戏" class="headerlink" title="心理小游戏"></a>心理小游戏</h2><ul><li><p>写下你的墓志铭</p></li><li><p>生命线</p></li></ul><p>在一张白纸上，画上一条箭头直线，然后，在线条的左侧，写上“0”这个数字，在线条右方，箭头旁边，写上你为自己预计的寿数。可以写68，也可以写100。</p><p>摸着这生命线，想象你的未来计划你的未来，然后，返回你的生命线，请你按照你为自己规定的生命长度，找到你目前所在的那个点。比如你打算活七十五岁，你现在只有二十五岁，你就在整个线段的三分之一处，留下1个标志。之后，请在你的标志的左边，即代表这过去岁月的那部分，把对你有着重大影响的事件用笔标出来。</p><p>好事开心的事写在生命线的上面（可以用红色笔写出事情），坏事悲伤的事写在生命线下面（用黑色或者灰色笔写出事情）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;登天的感觉&quot;&gt;&lt;a href=&quot;#登天的感觉&quot; class=&quot;headerlink&quot; title=&quot;登天的感觉&quot;&gt;&lt;/a&gt;登天的感觉&lt;/h2&gt;&lt;p&gt;上个星期看完了岳晓东的《登天的感觉》，发现心理学其实挺有趣的。为什么我要看这本书呢？因为前个星期张雪峰老师来我们学校
      
    
    </summary>
    
      <category term="洛书" scheme="http://yoursite.com/categories/%E6%B4%9B%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式基础</title>
    <link href="http://yoursite.com/2019/03/15/linux%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/03/15/linux正则表达式基础/</id>
    <published>2019-03-15T11:46:34.625Z</published>
    <updated>2019-03-15T13:47:32.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep模式匹配命令"><a href="#grep模式匹配命令" class="headerlink" title="grep模式匹配命令"></a>grep模式匹配命令</h2><p><code>grep</code>命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。<code>grep</code>支持三种正则表达式引擎，分别用三个参数指定：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>POSIX扩展正则表达式，ERE</td></tr><tr><td>-G</td><td>POSIX基本正则表达式，BRE</td></tr><tr><td>-P</td><td>Perl正则表达式，PCRE</td></tr></tbody></table><p><code>grep</code>命令的常用参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>将二进制文件作为文本来进行匹配</td></tr><tr><td>-c</td><td>统计以模式匹配的数目</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示匹配文本所在行的行号</td></tr><tr><td>-v</td><td>反选，输出不匹配行的内容</td></tr><tr><td>-r</td><td>递归匹配查找</td></tr><tr><td>-A n</td><td>n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td>-B n</td><td>n为正整数，表示before的意思，除了列出匹配行之外，还列出后面的n行</td></tr><tr><td>–color = auto</td><td>将输出中的匹配项设置为自动颜色显示</td></tr></tbody></table><ul><li>数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾的所有字符串</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.*o&apos;</span><br><span class="line"># 将匹配以&apos;z&apos;开头以&apos;o&apos;结尾，中间包含一个任意字符的字符串</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;z.o&apos;</span><br><span class="line"># 将匹配以&apos;z&apos;开头,以任意多个&apos;o&apos;结尾的字符串</span><br><span class="line">$ echo &apos;zero\nzo\nzoo&apos; | grep &apos;zo*&apos;</span><br></pre></td></tr></table></figure><ul><li>选择</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># grep默认是区分大小写的，这里将匹配所有的小写字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[a-z]&apos;</span><br><span class="line"># 将匹配所有的数字</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[0-9]&apos;</span><br><span class="line"># 将匹配所有的数字</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:digit:]]&apos;</span><br><span class="line"># 将匹配所有的小写字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:lower:]]&apos;</span><br><span class="line"># 将匹配所有的大写字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:upper:]]&apos;</span><br><span class="line"># 将匹配所有的字母和数字，包括0-9,a-z,A-Z</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:alnum:]]&apos;</span><br><span class="line"># 将匹配所有的字母</span><br><span class="line">$ echo &apos;1234\nabcd&apos; | grep &apos;[[:alpha:]]&apos;</span><br></pre></td></tr></table></figure><h2 id="sed流编辑器"><a href="#sed流编辑器" class="headerlink" title="sed流编辑器"></a>sed流编辑器</h2><p>sed : 用于过滤和转换文本的流编辑器</p><p>sed 命令基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed [参数]... [执行命令] [输入文件]...</span><br><span class="line"># 形如：</span><br><span class="line">$ sed -i &apos;s/sad/happy/&apos; test # 表示将test文件中的&quot;sad&quot;替换为&quot;happy&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>安静模式，只打印受影响的行，默认打印输入数据的全部内容</td></tr><tr><td>-e</td><td>用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数</td></tr><tr><td>-f  filename</td><td>指定执行filename文件中的命令</td></tr><tr><td>-r</td><td>使用扩展正则表达式，默认为标准正则表达式</td></tr><tr><td>-i</td><td>将直接修改输入文件内容，而不是打印到标准输出设备</td></tr></tbody></table><p>sed执行命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[n1][,n2]command</span><br><span class="line">[n1][~step]command</span><br><span class="line"># 其中一些命令可以在后面加上作用范围，形如：</span><br><span class="line">$ sed -i &apos;s/sad/happy/g&apos; test # g表示全局范围</span><br><span class="line">$ sed -i &apos;s/sad/happy/4&apos; test # 4表示指定行中的第四个匹配字符串</span><br></pre></td></tr></table></figure><p>其中n1,n2表示输入内容的行号，它们之间为<code>,</code>逗号则表示从n1到n2行，如果为<code>～</code>波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>s</code></td><td>行内替换</td></tr><tr><td><code>c</code></td><td>整行替换</td></tr><tr><td><code>a</code></td><td>插入到指定行的后面</td></tr><tr><td><code>i</code></td><td>插入到指定行的前面</td></tr><tr><td><code>p</code></td><td>打印指定行，通常与<code>-n</code>参数配合使用</td></tr><tr><td><code>d</code></td><td>删除指定行</td></tr></tbody></table><h2 id="AWK文本处理语言"><a href="#AWK文本处理语言" class="headerlink" title="AWK文本处理语言"></a>AWK文本处理语言</h2><p>awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pattern &#123;action&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>当前输入文件名，若有多个文件，则只表示第一个。如果输入是来自标准输入，则为空字符串</td></tr><tr><td>$0</td><td>当前记录的内容</td></tr><tr><td>$N</td><td>N表示字段号，最大值为<code>NF</code>变量的值</td></tr><tr><td>FS</td><td>字段分隔符，由正则表达式表示，默认为” “空格</td></tr><tr><td>RS</td><td>输入记录分隔符，默认为”\n”，即一行为一个记录</td></tr><tr><td>NF</td><td>当前记录字段数</td></tr><tr><td>NR</td><td>已经读入的记录数</td></tr><tr><td>FNR</td><td>当前输入文件的记录数，请注意它与NR的区别</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认为” “空格</td></tr><tr><td>ORS</td><td>输出记录分隔符，默认为”\n”</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;grep模式匹配命令&quot;&gt;&lt;a href=&quot;#grep模式匹配命令&quot; class=&quot;headerlink&quot; title=&quot;grep模式匹配命令&quot;&gt;&lt;/a&gt;grep模式匹配命令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;grep&lt;/code&gt;命令用于打印输出文本中匹配的模式串，它使用
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>简单的文本处理</title>
    <link href="http://yoursite.com/2019/03/08/linux%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/08/linux简单的文本处理/</id>
    <published>2019-03-08T11:52:27.142Z</published>
    <updated>2019-03-08T12:13:00.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h2><p>tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 删除 &quot;hello shiyanlou&quot; 中所有的&apos;o&apos;,&apos;l&apos;,&apos;h&apos;</span><br><span class="line">$ echo &apos;hello shiyanlou&apos; | tr -d &apos;olh&apos;</span><br><span class="line"># 将&quot;hello&quot; 中的ll,去重为一个l</span><br><span class="line">$ echo &apos;hello&apos; | tr -s &apos;l&apos;</span><br><span class="line"># 将输入文本，全部转换为大写或小写输出</span><br><span class="line">$ echo &apos;input some text here&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;</span><br><span class="line"># 上面的&apos;[:lower:]&apos; &apos;[:upper:]&apos;你也可以简单的写作&apos;[a-z]&apos; &apos;[A-Z]&apos;,当然反过来将大写变小写也是可以的</span><br></pre></td></tr></table></figure><h2 id="col命令"><a href="#col命令" class="headerlink" title="col命令"></a>col命令</h2><p>col 命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col [option]</span><br></pre></td></tr></table></figure><h3 id="常用的选项有："><a href="#常用的选项有：" class="headerlink" title="常用的选项有："></a>常用的选项有：</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-x</td><td>将Tab转换为空格</td></tr><tr><td>-h</td><td>将空格转换为Tab(默认选项)</td></tr></tbody></table><h2 id="join命令"><a href="#join命令" class="headerlink" title="join命令"></a>join命令</h2><p>join命令可以将将两个文件中包含相同内容的那一行合并在一起。</p><h3 id="常用的选项有：-1"><a href="#常用的选项有：-1" class="headerlink" title="常用的选项有："></a>常用的选项有：</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定分隔符，默认为空格</td></tr><tr><td>-i</td><td>忽略大小写的差异</td></tr><tr><td>-1</td><td>指名第一个文件要用哪个字段来对比，默认对比第一个字段</td></tr><tr><td>-2</td><td>指名第二个文件要用哪个字段来对比，默认对比第一个字段</td></tr></tbody></table><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/shiyanlou</span><br><span class="line"># 创建两个文件</span><br><span class="line">$ echo &apos;1 hello&apos; &gt; file1</span><br><span class="line">$ echo &apos;1 shiyanlou&apos; &gt; file2</span><br><span class="line">$ join file1 file2</span><br><span class="line"># 将/etc/passwd与/etc/shadow两个文件合并，指定以&apos;:&apos;作为分隔符</span><br><span class="line">$ sudo join -t&apos;:&apos; /etc/passwd /etc/shadow</span><br><span class="line"># 将/etc/passwd与/etc/group两个文件合并，指定以&apos;:&apos;作为分隔符, 分别比对第4和第3个字段</span><br><span class="line">$ sudo join -t&apos;:&apos; -1 4 /etc/passwd -2 3 /etc/group</span><br></pre></td></tr></table></figure><h2 id="paste-命令"><a href="#paste-命令" class="headerlink" title="paste 命令"></a>paste 命令</h2><p><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</p><h3 id="常用的选项有：-2"><a href="#常用的选项有：-2" class="headerlink" title="常用的选项有："></a>常用的选项有：</h3><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>指定合并的分隔符，默认为Tab</td></tr><tr><td>-s</td><td>不合并到一行，每个文件为一行</td></tr></tbody></table><h3 id="操作举例："><a href="#操作举例：" class="headerlink" title="操作举例："></a>操作举例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo hello &gt; file1</span><br><span class="line">$ echo shiyanlou &gt; file2</span><br><span class="line">$ echo www.shiyanlou.com &gt; file3</span><br><span class="line">$ paste -d &apos;:&apos; file1 file2 file3</span><br><span class="line">$ paste -s file1 file2 file3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tr命令&quot;&gt;&lt;a href=&quot;#tr命令&quot; class=&quot;headerlink&quot; title=&quot;tr命令&quot;&gt;&lt;/a&gt;tr命令&lt;/h2&gt;&lt;p&gt;tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。&lt;/p&gt;
&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>HTC VIVE - 2</title>
    <link href="http://yoursite.com/2019/03/03/vive2/"/>
    <id>http://yoursite.com/2019/03/03/vive2/</id>
    <published>2019-03-03T13:07:31.558Z</published>
    <updated>2019-03-04T02:23:22.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SteamVR渲染机制"><a href="#SteamVR渲染机制" class="headerlink" title="SteamVR渲染机制"></a>SteamVR渲染机制</h2><ol><li>等待相机和GUI的渲染完成</li><li>设置跟踪空间</li><li>获取设备位置，通知更新</li><li>渲染外部相机</li><li>渲染左右眼</li></ol><h2 id="vive的基站工作原理"><a href="#vive的基站工作原理" class="headerlink" title="vive的基站工作原理"></a>vive的基站工作原理</h2><p>vive的基站工作原理有点像超市买东西用来扫描的扫描器，不够那个用的是可见激光，vive用的是不可见激光（红外线)。<br>结构：<br>基站里面有两个马达，一个横着转一个竖着转。他们上面有一个激光发射器发出一道很细的不可见激光，随着马达的转动它们射出的激光线扫过整个房间。中间有一个红外列阵。</p><p><img src="http://www.52vr.com/data/attachment/portal/201605/06/185933l88s9qrgj4sjbpp4.jpg" alt=""></p><p>红色的是激光发射器（在马达上的）绿色的是红外列阵。<br>原理：</p><ol><li>基站会频繁的发出4个信号，第一是由红外列阵发出的红外线，代表开始扫描，可以覆盖整个追踪面积；第二竖向激光扫描，第三是横向激光扫描，第四又是由红外列阵发出的，代表扫描结束。</li><li>vive和vive控制器上有多个红外接收器，它们会接受第一个信号并且开始计时，当2个信号被接收到的时候结束竖向计时，第3个信号结束横向计时，第四个信号重置。</li><li>因为马达的转速是已知的，所以通过时间差可以计算出接收点相对接收器的位置，又因为基站是固定的，可以计算出接收点的位置。</li><li>接收器上有多个接收点，通过接收点之间的距离可以计算出vive头显和控制器的完全位置以及状态。</li></ol><p><img src="http://www.52vr.com/data/attachment/portal/201605/06/185934x7yt0j143r20xyrx.jpg" alt=""></p><p>竖向扫描</p><p><img src="http://www.52vr.com/data/attachment/portal/201605/06/185934zkyvb8giivhx4bii.jpg" alt=""></p><p>横向扫描</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SteamVR渲染机制&quot;&gt;&lt;a href=&quot;#SteamVR渲染机制&quot; class=&quot;headerlink&quot; title=&quot;SteamVR渲染机制&quot;&gt;&lt;/a&gt;SteamVR渲染机制&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;等待相机和GUI的渲染完成&lt;/li&gt;
&lt;li&gt;设置跟踪空
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="VR" scheme="http://yoursite.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>Share-2</title>
    <link href="http://yoursite.com/2019/03/02/share-2/"/>
    <id>http://yoursite.com/2019/03/02/share-2/</id>
    <published>2019-03-02T05:35:42.810Z</published>
    <updated>2019-03-22T11:09:41.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Fun"><a href="#Fun" class="headerlink" title="Fun"></a>Fun</h2><ol><li><p><a href="https://danielmiessler.com/blog/dns-servers-you-should-have-memorized/" target="_blank" rel="noopener">DNS Servers That Offer Privacy and Filtering</a></p><p> 作者介绍了几个常用的DNS服务器地址，简单谈了它们之间的差异。</p></li></ol><ol start="2"><li><p><a href="https://thispersondoesnotexist.com/" target="_blank" rel="noopener">This Person Does Not Exist</a></p><p>这个网站，每刷新一次就会出现一张人脸。所有的人脸都是AI生成的，现实中不存在。</p></li></ol><ol start="3"><li><p>猫屎咖啡</p><p>猫屎咖啡是世界上最贵的咖啡之一，是印尼麝香猫吃下咖啡浆果排泄出的咖啡豆制成的。过去，人们是在树林捡拾野生麝香猫排泄的天然咖啡豆，数量稀少且生产速度慢，于是咖啡商人开始人工养殖麝香猫，以求大量生产猫屎咖啡。</p></li></ol><ol start="4"><li><p>乐器博物馆</p><p> 意大利克雷莫纳，历史上是一个著名的小提琴制作城市。著名的斯特拉迪瓦里小提琴，就是在那里制作的。下图是当地的小提琴博物馆。</p></li></ol><ol start="5"><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjEyOTIyMA==&amp;mid=2651467048&amp;idx=1&amp;sn=1273aa18d189186e38d448d0662ebda3" target="_blank" rel="noopener">《流浪地球》超详细设计图、理念分享</a></li></ol><p><img src="\images\four.jpg" alt=""></p><ol start="5"><li><p>估计日落的时间</p><p> <img src="https://www.wangbase.com/blogimg/asset/201902/bg2019022233.jpg" alt=""></p><p> 太阳将要落山的时候，你可以把手放在太阳和地平线之间，估计日落的大概时间。如果可以放四根手指，就是1个小时后落山，三根手指45分钟，两根手指30分钟，一根手指15分钟。</p></li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><p><a href="https://www.lucidchart.com/" target="_blank" rel="noopener">LucidChart</a><br> 一款流程图工具，与大家熟知的 ProcessOn 功能操作类似，但图形和模板更丰富些，如果你受不了 ProcessOn 的种种小毛病，或者觉得模板不漂亮，可以试试这款工具。</p><p> <img src="https://ws1.sinaimg.cn/large/62bfa70bly1g0nd1ytfq6j21r20nan07.jpg" alt=""></p></li><li><p><a href="https://github.com/cool2528/baiduCDP" target="_blank" rel="noopener">百度网盘下载神器</a><br> <img src="https://camo.githubusercontent.com/eeff5737a538c133de62d291514d22c8b5d5e1a2/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30322f32312f356336653161356539626261352e676966" alt=""></p></li></ol><ol start="3"><li><p><a href="https://leetcode-cn.com/explore/" target="_blank" rel="noopener">LeetCode</a></p><p>LeetCode是一个美国的在线编程网站，上面主要收集了各大IT公司的笔试面试题，对于找工作是一个不可多得的好帮手。如果想要练习编程基础或者准备面试的话，非常适合。</p></li></ol><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ol><li><p><a href="http://stevesspace.com/2019/02/how-does-hololens2-matter/" target="_blank" rel="noopener">How does the Hololens 2 matter? </a></p><p> This release is super exciting, I can’t wait to get my hands on one and see what it can do.</p></li><li><p><a href="https://functionalcs.github.io/curriculum/" target="_blank" rel="noopener">计算机科学的自学方案</a></p><p> 本文对于计算机科学各门课程的自学，给出了一个完整的方案。</p></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ol><li><a href="https://mp.weixin.qq.com/s/ijNTMluqmGgDdZx56REdCQ" target="_blank" rel="noopener">施一公：如何成为一名优秀的博士生？</a></li><li><a href="https://zhuanlan.zhihu.com/p/22581673" target="_blank" rel="noopener">什么是点云？</a></li><li><a href="https://jerryding.site/linux-experience/" target="_blank" rel="noopener">使用Linux系统是一种怎样的体验</a></li><li><a href="http://www.thejumperwire.com/articles/controlling-a-quadcopter-with-hand-gestures/" target="_blank" rel="noopener">Controlling a Quadcopter with Hand Gestures</a></li></ol><h2 id="藏经阁"><a href="#藏经阁" class="headerlink" title="藏经阁"></a>藏经阁</h2><ul><li><p>回顾其过去，能看清其千丝万缕的联系。                                                          -苏牧云</p></li><li><p>要学会挖掘数据背后的潜在价值。                                                                     -苏牧云</p></li><li><p>越是复杂的问题，背后的原理越是简单。有时候，应该让生活过得简单一些。-苏牧云</p></li></ul><h2 id="藏宝图"><a href="#藏宝图" class="headerlink" title="藏宝图"></a>藏宝图</h2><p><img src="\images\two.jpg" alt="编程语言排行榜"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Fun&quot;&gt;&lt;a href=&quot;#Fun&quot; class=&quot;headerlink&quot; title=&quot;Fun&quot;&gt;&lt;/a&gt;Fun&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://danielmiessler.com/blog/dns-servers-you-
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>linux命令执行顺序控制与管道</title>
    <link href="http://yoursite.com/2019/03/01/linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2019/03/01/linux命令执行顺序控制与管道/</id>
    <published>2019-03-01T12:28:02.113Z</published>
    <updated>2019-03-01T13:28:58.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令执行顺序的控制"><a href="#命令执行顺序的控制" class="headerlink" title="命令执行顺序的控制"></a>命令执行顺序的控制</h1><h2 id="顺序执行多条命令"><a href="#顺序执行多条命令" class="headerlink" title="顺序执行多条命令"></a>顺序执行多条命令</h2><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#更新软件源里的软件列表</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install some-tool //这里some-tool是指具体的软件包，例如：banner</span><br><span class="line">$ some-tool</span><br></pre></td></tr></table></figure></p><h2 id="有选择的执行命令"><a href="#有选择的执行命令" class="headerlink" title="有选择的执行命令"></a>有选择的执行命令</h2><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which cowsay&gt;/dev/null &amp;&amp; cowsay -f head-in ohch~</span><br></pre></td></tr></table></figure></p><p>你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。</p><p>上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果：</p><p><img src="https://doc.shiyanlou.com/document-uid1labid63timestamp1544148440172.png/wm" alt=""></p><p>||就是与&amp;&amp;相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ which cowsay&gt;/dev/null || echo &quot;cowsay has not been install, please run &apos;sudo apt-get install cowsay&apos; to install&quot;</span><br></pre></td></tr></table></figure></p><p>流程图：</p><p><img src="https://doc.shiyanlou.com/linux_base/8-3.png/wm" alt=""></p><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>管道是什么？管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。</p><p>管道又分为匿名管道和具名管道，在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由<code>|</code>分隔符表示,具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。</p><p>先试用一下管道，比如查看/etc目录下有哪些文件和目录，使用ls命令来查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /etc</span><br></pre></td></tr></table></figure></p><p>有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al /etc | less</span><br></pre></td></tr></table></figure></p><p>通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。</p><h2 id="cut-命令，打印每一行的某一字段"><a href="#cut-命令，打印每一行的某一字段" class="headerlink" title="cut 命令，打印每一行的某一字段"></a>cut 命令，打印每一行的某一字段</h2><p>打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut /etc/passwd -d &apos;:&apos; -f 1,6</span><br></pre></td></tr></table></figure></p><p>打印/etc/passwd文件中每一行的前N个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 前五个（包含第五个）</span><br><span class="line">$ cut /etc/passwd -c -5</span><br><span class="line"># 前五个之后的（包含第五个）</span><br><span class="line">$ cut /etc/passwd -c 5-</span><br><span class="line"># 第五个</span><br><span class="line">$ cut /etc/passwd -c 5</span><br><span class="line"># 2到5之间的（包含第五个）</span><br><span class="line">$ cut /etc/passwd -c 2-5</span><br></pre></td></tr></table></figure></p><h2 id="grep-命令，在文本中或-stdin-中查找匹配字符串"><a href="#grep-命令，在文本中或-stdin-中查找匹配字符串" class="headerlink" title="grep 命令，在文本中或 stdin 中查找匹配字符串"></a>grep 命令，在文本中或 stdin 中查找匹配字符串</h2><p>grep命令的一般形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [命令选项]... 用于匹配的表达式 [文件]...</span><br></pre></td></tr></table></figure></p><p>搜索/home/shiyanlou目录下所有包含”shiyanlou”的文本文件，并显示出现在文本中的行号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep -rnI &quot;shiyanlou&quot; ~</span><br></pre></td></tr></table></figure></p><ul><li>-r 参数表示递归搜索子目录中的文件</li><li>-n表示打印匹配项行号</li><li>-I表示忽略二进制文件</li></ul><p>当然也可以在匹配字段中使用正则表达式，下面简单的演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看环境变量中以&quot;yanlou&quot;结尾的字符串</span><br><span class="line">$ export | grep &quot;.*yanlou$&quot;</span><br></pre></td></tr></table></figure><ul><li>$表示一行的末尾</li></ul><h2 id="wc-命令，简单小巧的计数工具"><a href="#wc-命令，简单小巧的计数工具" class="headerlink" title="wc 命令，简单小巧的计数工具"></a>wc 命令，简单小巧的计数工具</h2><p>wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wc /etc/passwd</span><br></pre></td></tr></table></figure></p><p>分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 行数</span><br><span class="line">$ wc -l /etc/passwd</span><br><span class="line"># 单词数</span><br><span class="line">$ wc -w /etc/passwd</span><br><span class="line"># 字节数</span><br><span class="line">$ wc -c /etc/passwd</span><br><span class="line"># 字符数</span><br><span class="line">$ wc -m /etc/passwd</span><br><span class="line"># 最长行字节数</span><br><span class="line">$ wc -L /etc/passwd</span><br></pre></td></tr></table></figure></p><h2 id="sort-排序命令"><a href="#sort-排序命令" class="headerlink" title="sort 排序命令"></a>sort 排序命令</h2><p>这个命令前面我们也是用过多次，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。</p><p>默认为字典排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort</span><br></pre></td></tr></table></figure></p><p>反转排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -r</span><br></pre></td></tr></table></figure></p><p>按特定字段排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t&apos;:&apos; -k 3</span><br></pre></td></tr></table></figure></p><ul><li>-t参数用于指定字段的分隔符，这里是以”:”作为分隔符；</li><li>-k 字段号用于指定对哪一个字段进行排序。</li></ul><p>这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n</span><br></pre></td></tr></table></figure></p><h2 id="uniq-去重命令"><a href="#uniq-去重命令" class="headerlink" title="uniq 去重命令"></a>uniq 去重命令</h2><p>uniq命令可以用于过滤或者输出重复行。</p><h3 id="过滤重复行"><a href="#过滤重复行" class="headerlink" title="过滤重复行"></a>过滤重复行</h3><p>我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | uniq</span><br></pre></td></tr></table></figure></p><p>然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq</span><br><span class="line"># 或者$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort -u</span><br></pre></td></tr></table></figure></p><p>这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。</p><h3 id="输出重复行"><a href="#输出重复行" class="headerlink" title="输出重复行"></a>输出重复行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 输出重复过的行（重复的只输出一个）及重复次数</span><br><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -dc</span><br><span class="line"># 输出所有重复的行</span><br><span class="line">$ history | cut -c 8- | cut -d &apos; &apos; -f 1 | sort | uniq -D</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;命令执行顺序的控制&quot;&gt;&lt;a href=&quot;#命令执行顺序的控制&quot; class=&quot;headerlink&quot; title=&quot;命令执行顺序的控制&quot;&gt;&lt;/a&gt;命令执行顺序的控制&lt;/h1&gt;&lt;h2 id=&quot;顺序执行多条命令&quot;&gt;&lt;a href=&quot;#顺序执行多条命令&quot; class=&quot;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>HTC VIVE - 1</title>
    <link href="http://yoursite.com/2019/02/28/vive1/"/>
    <id>http://yoursite.com/2019/02/28/vive1/</id>
    <published>2019-02-28T06:40:28.960Z</published>
    <updated>2019-03-03T13:08:34.081Z</updated>
    
    <content type="html"><![CDATA[<p>安装VIVE和SteamVR至少需要占用1020MB的磁盘空间。</p><h2 id="技术规格"><a href="#技术规格" class="headerlink" title="技术规格"></a>技术规格</h2><p>“HTC Vive”具有90赫兹的刷新速率。该设备使用两个屏幕，每眼一个屏幕，每个屏幕具有1080×1200分辨率。</p><p>最低系统要求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GPU: NVIDIA GeForce GTX 970 / AMD Radeon R9 290 同等或更高的版本</span><br><span class="line">CPU: Intel i5-4590 / AMD FX-8350 同等或更高的版本</span><br><span class="line">RAM: 4GB+</span><br><span class="line">Video Output: HDMI 1.4 或 DisplayPort 1.2 或更高版本</span><br><span class="line">USB Port: 1x USB 2.0 或更高版本</span><br><span class="line">操作系统: Windows 7 SP1 或更新版本[8]</span><br></pre></td></tr></table></figure></p><h2 id="Viveport-M简介"><a href="#Viveport-M简介" class="headerlink" title="Viveport M简介"></a>Viveport M简介</h2><p>Viveport M是HTC面向移动市场推出的虚拟现实应用商店，适用于Android平台并广泛兼容多种移动VR设备，其内容将以360°视频和体验类游戏为主，旨在为用户提供更多元化、更高品质的移动VR内容与体验。Viveport M将为全球数以万计的开发者提供一个展示内容的新平台，吸引更多开发者和合作伙伴加入到蓬勃发展的Vive生态系统中，接触到全球增长速度最快的用户群体。<br>系统支持：安卓5.0及以上；屏幕尺寸：5-6寸</p><h2 id="手柄"><a href="#手柄" class="headerlink" title="手柄"></a>手柄</h2><p>1 开关、系统菜单按钮：只有这个按钮不可以编程（默认），用来打开手柄，其实没用关的功能。在游戏中按下该按钮是调出系统默认的菜单，用来关闭，切换游戏用的。</p><p>2 menu按钮：默认用来打开游戏菜单。</p><p>3 grip按钮：用的最少的按钮，每个手柄上虽然有两个，但是是相同的。</p><p>4 trigger按钮：扳机按钮，用的最多，可以有力度。</p><p>5 pad：触摸屏+鼠标的功能，可触摸，可点击。</p><h2 id="vive开发"><a href="#vive开发" class="headerlink" title="vive开发"></a>vive开发</h2><p>需要两个插件：</p><p><a href="https://www.assetstore.Unity3D.com/cn/#!/content/32647" target="_blank" rel="noopener">SteamVR Plugin</a></p><p><a href="https://www.assetstore.unity3d.com/cn/#!/content/64219" target="_blank" rel="noopener">Vive Input Utility</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">SteamVR </span><br><span class="line"></span><br><span class="line">这个目录下的脚本都是用来定制SteamVR插件中某些脚本在Unity中的Inspector界面及功能的</span><br><span class="line">——Editor</span><br><span class="line"></span><br><span class="line">    定制SteamVR_Camera.cs这个脚本在Inspector中的显示效果 </span><br><span class="line">    SteamVR_Editor.cs  </span><br><span class="line">    定制SteamVR_RenderModel.cs脚本在Inspector中的功能 </span><br><span class="line">    SteamVR_RenderModelEditor.cs　 </span><br><span class="line">    上面提到的弹出的SteamVR_Settings对话框里面的选项就在这儿定制 </span><br><span class="line">    SteamVR_Settings.cs　　　　　　 </span><br><span class="line">    定制SteamVR_SkyBox.cs在Inspector中显示的属性</span><br><span class="line">    SteamVR_SkyboxEditor.cs　　　　 </span><br><span class="line">    用来检查插件的更新　　 </span><br><span class="line">    SteamVR_Update.cs　　</span><br><span class="line">　　　　　 </span><br><span class="line">这个文件夹下面放着一些工具脚本　　　　　 </span><br><span class="line">——Extras　　　　 </span><br><span class="line"></span><br><span class="line">    这个脚本用来检测物体是否被用户所凝视　　　　</span><br><span class="line">    SteamVR_GazeTracker.cs 　　　　 </span><br><span class="line">    通过手柄指向来产生一条激光束 </span><br><span class="line">    SteamVR_LeaserPointer.cs　　　　</span><br><span class="line">    用来瞬移的脚本 </span><br><span class="line">    SteamVR_Teleporter.cs　　　　　 </span><br><span class="line">    示例场景中扔物体的脚本</span><br><span class="line">    SteamVR_TestThrow.cs　　　　　　</span><br><span class="line">    示例场景中跟踪相机的脚本 </span><br><span class="line">    SteamVR_TestTrackedCamera.cs　 </span><br><span class="line">    控制器(手柄)集成脚本</span><br><span class="line">    SteamVR_trackedController.cs　 </span><br><span class="line"></span><br><span class="line">存放示例demo的材质体　　 </span><br><span class="line">——Materials </span><br><span class="line">存放SteamVR预制体</span><br><span class="line">——Prefabs </span><br><span class="line"></span><br><span class="line">    相机预制体　 </span><br><span class="line">    [CameraRig] </span><br><span class="line">    状态相关的overlay显示预制体　 </span><br><span class="line">    [Status] </span><br><span class="line">    /*SteamVR_Render预制体*/　 </span><br><span class="line">    [SteamVR] </span><br><span class="line"></span><br><span class="line">/*一些自带的shader*/　 </span><br><span class="line">——Scenes</span><br><span class="line">/*SteamVR核心脚本*/　 </span><br><span class="line">——Scripts </span><br><span class="line">    /*SteamVR的封装类*/ </span><br><span class="line">    SteamVR.cs </span><br><span class="line">    /*SteamVR的核心相机类*/ </span><br><span class="line">    SteamVR_Camera.cs </span><br><span class="line">    /*SteamVR相机翻转*/ </span><br><span class="line">    SteamVR_CameraFlip.cs </span><br><span class="line">    /*SteamVR相机网格隐藏*/ </span><br><span class="line">    SteamVR_CameraMask.cs </span><br><span class="line">    /*控制器封装类*/ </span><br><span class="line">    SteamVR_Controller.cs </span><br><span class="line">    /*控制器管理类*/ </span><br><span class="line">    SteamVR_ControllerManager.cs </span><br><span class="line">    /*声音控制类*/ </span><br><span class="line">    SteamVR_Ears.cs </span><br><span class="line">    /*外部相机*/ </span><br><span class="line">    SteamVR_ExternalCamera.cs </span><br><span class="line">    /*场景进行渐显或者渐隐的类*/ </span><br><span class="line">    SteamVR_Fade.cs </span><br><span class="line">    /*跟踪设备的扫描范围*/ </span><br><span class="line">    SteamVR_Frustum.cs </span><br><span class="line">    /*绘制pc上的伴随窗口*/ </span><br><span class="line">    SteamVR_GameView.cs </span><br><span class="line">    /*关节反身运动*/ </span><br><span class="line">    SteamVR_IK.cs </span><br><span class="line">    /*场景切换类*/ </span><br><span class="line">    SteamVR_LoadLevel.cs </span><br><span class="line">    /*菜单类*/ </span><br><span class="line">    SteamVR_Menu.cs </span><br><span class="line">    /*overly封装类*/ </span><br><span class="line">    SteamVR_Overlay.cs </span><br><span class="line">    /*运动区域*/ </span><br><span class="line">    SteamVR_PlayArea.cs </span><br><span class="line">    /*Vive渲染流程控制的核心类*/ </span><br><span class="line">    SteamVR_Render.cs </span><br><span class="line">    /*设置天空盒*/ </span><br><span class="line">    SteamVR_Skybox.cs </span><br><span class="line">    /*做球形投影的类*/ </span><br><span class="line">    SteamVR_SphericalProjection.cs </span><br><span class="line">    /*通过overlay显示统计信息*/ </span><br><span class="line">    SteamVR_Stats.cs </span><br><span class="line">    /*根据不同状态渐变显示不同的信息*/ </span><br><span class="line">    SteamVR_Status.cs </span><br><span class="line">    /*根据不同状态渐变显示不同文本信息*/ </span><br><span class="line">    SteamVR_StatusText.cs </span><br><span class="line">    /*控制器测试脚本*/ </span><br><span class="line">    SteamVR_TestController.cs </span><br><span class="line">    /*头盔上的前置相机*/ </span><br><span class="line">    SteamVR_TrackedCamera.cs </span><br><span class="line">    /*跟踪设备管理类*/ </span><br><span class="line">    SteamVR_TrackedObject.cs </span><br><span class="line">    /*5.x版本以前更新设备位置的脚本*/ </span><br><span class="line">    SteamVR_UpdatePoses.cs </span><br><span class="line">    /*工具类，包括事件系统，Transform等等*/ </span><br><span class="line">    SteamVR_Utils.cs </span><br><span class="line">    </span><br><span class="line">/*常用的纹理*/ </span><br><span class="line">——Textures</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装VIVE和SteamVR至少需要占用1020MB的磁盘空间。&lt;/p&gt;
&lt;h2 id=&quot;技术规格&quot;&gt;&lt;a href=&quot;#技术规格&quot; class=&quot;headerlink&quot; title=&quot;技术规格&quot;&gt;&lt;/a&gt;技术规格&lt;/h2&gt;&lt;p&gt;“HTC Vive”具有90赫兹的刷新速率。
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="VR" scheme="http://yoursite.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>Hololens2</title>
    <link href="http://yoursite.com/2019/02/25/hololens2/"/>
    <id>http://yoursite.com/2019/02/25/hololens2/</id>
    <published>2019-02-25T14:10:28.944Z</published>
    <updated>2019-03-02T13:22:44.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hololens2"><a href="#Hololens2" class="headerlink" title="Hololens2"></a>Hololens2</h1><p>售价3500美元</p><p>具有强大的环境感知能力，和信息展示能力。强大的本地计算能力（HPU2），还可连接云端后台来增强。</p><p>Hololens 2本体的几个亮点：</p><ul><li>FOV * 2；  Hololens 2的FOV大约从30°增加到了52°，同时达到每个视距47像素。</li><li>眼球追踪； 眼球追踪也是一个重头戏，Hololens 2 利用了一个小摄像头实现了这个功能。<br>允许其精确追踪你的两只眼睛，并判断具体的注视点位置。与此同时，设备支持Windows Hello和虹膜识别登录，从而允许多人轻松，快速，安全地共享设备。</li><li>完全的手指跟踪； 基本上实现了Alex承诺的’instinctual control’。</li><li>显示系统: MEMS激光显示器，而且这是当前市场上最小和最高能效的2K显示器。</li></ul><p>除了高通骁龙 850 处理器，HoloLens 2 还内置了 AI 处理单元。因此，它能够直接连接到微软的 Azure 云服务。「这意味着某些 AI 任务会被移交给云计算处理，最终的运算结果将会更加精确——类似一厘米空间映射（spatial mapping）和一毫米空间映射的区别。头显处理这些任务仍需几秒钟时间，Kipman 相信这是企业用户可以接受的延迟时长。」《连线》报道称。早在去年 10 月，微软就已推出 Dynamics 365 Remote Assist 和 Dynamics 365 Layout 两个 app。前者为 MR 头显的使用者提供远程帮助；后者将通过云记住用户创建的虚拟图像，并将它固定在特定的地方，以便多名协作用户查找。</p><p>在北京时间今天凌晨的 MWC 发布会上，微软推出了全新的员工培训应用 Dynamics 365 Guides。「就好像是为现实世界准备的，能一步步引导你的谷歌地图。」CNET 的记者这样形容。Dynamics 365 Guides 的 PC 端应用还能创建交互式内容，包括添加图片和视频，3D 模型等。</p><p>如果将设备连接至全新的Azure Remote Rendering混合现实云端服务，你将可以快速生成复杂的三维数字模型，而原本企业可能需要花费数天或数月的时间才能构建出与之媲美的模型细节。如果没有云端的图形处理能力，这是不可能实现的任务。Azure Remote Rendering可以帮助人们自由体验3D，从而实现更快，更优的决策。微软认为，今天如果要通过移动设备和混合现实头显与高质量3D模型进行交互，你通常需要“抽取”或简化3D模型。但对于设计评审和医疗规划等场景，每个细节都非常重要，而简化asset可能会导致关键决策所需的重要细节丢失。Azure Remote Rendering可以在云端渲染高质量的3D内容，并将其全部实时传输至边缘设备，而且能够确保“每个细节都完好无损”。</p><blockquote><p>如果把未来的公司比作一个厨房，那么云服务大概是水电煤，数据就是基础原料，AI算法服务是不同的菜谱，操作系统则是一台功能齐备的厨师机，目前这厨房里的所有设备微软全都齐备，并且都在为未来布局。</p></blockquote><p>技术规格:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">光学：透视全息透镜（波导）</span><br><span class="line"></span><br><span class="line">分辨率：2k 3：2光引擎</span><br><span class="line"></span><br><span class="line">全息密度：&gt; 2.5k辐射点（每弧度光点）</span><br><span class="line"></span><br><span class="line">注视点渲染：针对3D眼睛位置显示的优化</span><br><span class="line"></span><br><span class="line">深度传感器：Azure Kinect传感器</span><br><span class="line"></span><br><span class="line">IMU：加速度计，陀螺仪，磁力计</span><br><span class="line"></span><br><span class="line">摄像头：800万像素，1080P/30帧视频</span><br><span class="line"></span><br><span class="line">麦克风阵列：5组</span><br><span class="line"></span><br><span class="line">扬声器：内置空间音频</span><br><span class="line"></span><br><span class="line">手部追踪：双手全关节模型，直接操纵</span><br><span class="line"></span><br><span class="line">眼动追踪：实时追踪</span><br><span class="line"></span><br><span class="line">语音 ：板载命令与控制，具有互联网连接的自然语言</span><br><span class="line"></span><br><span class="line">六自由度追踪：世界规模的位置追踪</span><br><span class="line"></span><br><span class="line">空间映射：实时环境网格</span><br><span class="line"></span><br><span class="line">混合现实捕获：混合全息图和物理环境照片和视频</span><br><span class="line"></span><br><span class="line">SoC：高通骁龙850计算平台，不支持4G LTE</span><br><span class="line"></span><br><span class="line">HPU：第二代定制全息处理单元</span><br><span class="line"></span><br><span class="line">WiFi：802.11ac 2×2</span><br><span class="line"></span><br><span class="line">蓝牙：5.0</span><br><span class="line"></span><br><span class="line">USB：USB Type-C</span><br><span class="line"></span><br><span class="line">续航能力：2-3小时的有效使用时间</span><br><span class="line"></span><br><span class="line">充电：USB供电 – 快速充电</span><br><span class="line"></span><br><span class="line">热量：被动冷却</span><br><span class="line"></span><br><span class="line">佩戴：适合眼镜，可使用表盘调节</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.yivian.com/wp-content/uploads/2019/02/cbbf5bbe94ecece41f61acfdb246d2b9.jpg" alt=""></p><h1 id="Azure-Kinect"><a href="#Azure-Kinect" class="headerlink" title="Azure Kinect"></a>Azure Kinect</h1><p>微软同时发布了一款新的Azure Kinect设备，为开发者提供了创建人工智能体验的新方式。Azure Kinect将HoloLens 2中的深度感应摄像头技术与圆形麦克风阵列和彩色摄像头相结合，并搭配以Microsoft Azure中的人工智能服务。它可以帮助开发者建立新的感知功能，如根据锯子的声音识别其是否属于危险的运行情况，支持机器人在装箱时判断距离，或者是识别从商店货架中选择的物品。</p><p><img src="https://pic3.zhimg.com/80/v2-46b5d734136d099176cff8c55d3eda7e_hd.jpg" alt=""></p><p>第四代的Kinect，结合了在边缘运行的AI工具。这种深度和动作感知技术最初是在十年前开发，并旨在为Xbox创建手势识别附件。但对于可以准确感知深度并确定人体在空间中移动的能力，其潜力远远不局限于游戏。例如，Ocuvera正与Azure Kinect合作开发这样一种系统：旨在帮助防止每年在美国医院发生的大约100万次跌倒，甚至是全球范围内的更多跌倒。他们研发的系统可以感知需要帮助行走的患者是于何时无助地下床，并提前预警护士以提供帮助。利用深度感应摄像头和人工智能算法，系统可以在患者起床前识别出运动模式，如坐起或摆动腿部的动作。11个临床试点的初步研究结果发现，在实施上述技术后，无辅助和未留意的下床行走减少了90％以上。首席执行官史蒂夫·凯恩（Steve Kiene）表示，Ocuvera团队调查了世界每一台深度感应摄像头，甚至试图开发自家的深度感应摄像头。但对于区分病人是向前移动抑或只是翻身，没有任何一款设备能够接近于Azure Kinect的准确性和分辨率。他说道：“这就像玩扑克时的认牌一样。只有Azure Kinect能够为我们提供可以真正了解患者在病床上发生的情况，并以足够的准确度预测其意图的数据。当我们在医院进行试点测试时，他们经常告诉我们这是不可能的做到的事情，但随后他们发现它确实有效，而且他们感到非常惊讶。”</p><p>参考文章</p><ol><li><p><a href="https://link.zhihu.com/?target=https%3A//yivian.com/news/57176.html" target="_blank" rel="noopener">售价3500美元，中国首发，微软HoloLens 2正式发布 - 映维网</a></p></li><li><p><a href="https://link.zhihu.com/?target=https%3A//yivian.com/news/57215.html" target="_blank" rel="noopener">十年一剑！微软HoloLens 2是如何沸腾下一代计算平台 - 映维网</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hololens2&quot;&gt;&lt;a href=&quot;#Hololens2&quot; class=&quot;headerlink&quot; title=&quot;Hololens2&quot;&gt;&lt;/a&gt;Hololens2&lt;/h1&gt;&lt;p&gt;售价3500美元&lt;/p&gt;
&lt;p&gt;具有强大的环境感知能力，和信息展示能力。强大的本地计
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="Hololens" scheme="http://yoursite.com/tags/Hololens/"/>
    
  </entry>
  
  <entry>
    <title>linux帮助命令和crontab</title>
    <link href="http://yoursite.com/2019/02/21/linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/02/21/linux帮助命令/</id>
    <published>2019-02-21T14:43:51.057Z</published>
    <updated>2019-02-21T15:24:49.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内建命令与外部命令"><a href="#内建命令与外部命令" class="headerlink" title="内建命令与外部命令"></a>内建命令与外部命令</h2><p>可以用type来区分命令是内建的还是外部的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type + 命令</span><br></pre></td></tr></table></figure></p><ul><li>内建命令是写在bash源码的builtins里面的</li><li>外部命令通常放在/bin，/user/bin,/sbin,/usr/sbin等等</li></ul><h2 id="crontab语法"><a href="#crontab语法" class="headerlink" title="crontab语法"></a>crontab语法</h2><p>用于设置周期性被执行的指令。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</p><p>通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell　script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。</p><p>crontab 的格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name command to be executed</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e 表示为当前用户添加计划任务</span><br><span class="line">$ sudo crontab -e 表示为root用户添加计划任务</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内建命令与外部命令&quot;&gt;&lt;a href=&quot;#内建命令与外部命令&quot; class=&quot;headerlink&quot; title=&quot;内建命令与外部命令&quot;&gt;&lt;/a&gt;内建命令与外部命令&lt;/h2&gt;&lt;p&gt;可以用type来区分命令是内建的还是外部的&lt;br&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C# 反射（Reflection）</title>
    <link href="http://yoursite.com/2019/02/21/c%20sharp%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/02/21/c sharp反射/</id>
    <published>2019-02-21T07:21:06.272Z</published>
    <updated>2019-02-23T11:48:35.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射（Reflection）的用途"><a href="#反射（Reflection）的用途" class="headerlink" title="反射（Reflection）的用途"></a>反射（Reflection）的用途</h1><p>反射（Reflection）有下列用途：</p><ul><li>它允许在运行时查看特性（attribute）信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul><h2 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h2><p>使用反射（Reflection）可以查看特性（attribute）信息。</p><p>System.Reflection 类的 MemberInfo 对象需要被初始化，用于发现与类相关的特性（attribute）。为了做到这点，您可以定义目标类的一个对象，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.MemberInfo info = typeof(MyClass);</span><br></pre></td></tr></table></figure></p><p>下面的程序演示了这点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">[AttributeUsage(AttributeTargets.All)]</span><br><span class="line">public class HelpAttribute : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">   public readonly string Url;</span><br><span class="line"></span><br><span class="line">   public string Topic  // Topic 是一个命名（named）参数</span><br><span class="line">   &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">         return topic;</span><br><span class="line">      &#125;</span><br><span class="line">      set</span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">         topic = value;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public HelpAttribute(string url)  // url 是一个定位（positional）参数</span><br><span class="line">   &#123;</span><br><span class="line">      this.Url = url;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private string topic;</span><br><span class="line">&#125;</span><br><span class="line">[HelpAttribute(&quot;Information on the class MyClass&quot;)]</span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace AttributeAppl</span><br><span class="line">&#123;</span><br><span class="line">   class Program</span><br><span class="line">   &#123;</span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         System.Reflection.MemberInfo info = typeof(MyClass);</span><br><span class="line">         object[] attributes = info.GetCustomAttributes(true);</span><br><span class="line">         for (int i = 0; i &lt; attributes.Length; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            System.Console.WriteLine(attributes[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会显示附加到类 MyClass 上的自定义特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelpAttribute</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射（Reflection）的用途&quot;&gt;&lt;a href=&quot;#反射（Reflection）的用途&quot; class=&quot;headerlink&quot; title=&quot;反射（Reflection）的用途&quot;&gt;&lt;/a&gt;反射（Reflection）的用途&lt;/h1&gt;&lt;p&gt;反射（Reflect
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="c#" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C# 特性（Attribute）</title>
    <link href="http://yoursite.com/2019/02/21/c%20sharp%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/02/21/c sharp特性/</id>
    <published>2019-02-21T07:06:13.376Z</published>
    <updated>2019-02-23T11:49:19.555Z</updated>
    
    <content type="html"><![CDATA[<p>特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p><p>.Net 框架提供了两种类型的特性：预定义特性和自定义特性。</p><h1 id="预定义特性（Attribute）"><a href="#预定义特性（Attribute）" class="headerlink" title="预定义特性（Attribute）"></a>预定义特性（Attribute）</h1><p>.Net 框架提供了三种预定义特性：</p><ul><li>AttributeUsage</li><li>Conditional</li><li>Obsolete</li></ul><h1 id="创建自定义特性（Attribute）"><a href="#创建自定义特性（Attribute）" class="headerlink" title="创建自定义特性（Attribute）"></a>创建自定义特性（Attribute）</h1><p>创建并使用自定义特性包含四个步骤：</p><ul><li>声明自定义特性</li><li>构建自定义特性</li><li>在目标程序元素上应用自定义特性</li><li>通过反射访问特性</li></ul><h2 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h2><p>一个新的自定义特性应派生自 System.Attribute 类。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们已经声明了一个名为 DeBugInfo 的自定义特性。</p><h2 id="构建自定义特性"><a href="#构建自定义特性" class="headerlink" title="构建自定义特性"></a>构建自定义特性</h2><p>让我们构建一个名为 DeBugInfo 的自定义特性，该特性将存储调试程序获得的信息。它存储下面的信息：</p><ul><li>bug 的代码编号</li><li>辨认该 bug 的开发人员名字</li><li>最后一次审查该代码的日期</li><li>一个存储了开发人员标记的字符串消息</li></ul><p>我们的 DeBugInfo 类将带有三个用于存储前三个信息的私有属性（property）和一个用于存储消息的公有属性（property）。所以 bug 编号、开发人员名字和审查日期将是 DeBugInfo 类的必需的定位（ positional）参数，消息将是一个可选的命名（named）参数。</p><p>每个特性必须至少有一个构造函数。必需的定位（ positional）参数应通过构造函数传递。下面的代码演示了 DeBugInfo 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 一个自定义特性 BugFix 被赋给类及其成员</span><br><span class="line">[AttributeUsage(AttributeTargets.Class |</span><br><span class="line">AttributeTargets.Constructor |</span><br><span class="line">AttributeTargets.Field |</span><br><span class="line">AttributeTargets.Method |</span><br><span class="line">AttributeTargets.Property,</span><br><span class="line">AllowMultiple = true)]</span><br><span class="line"></span><br><span class="line">public class DeBugInfo : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">  private int bugNo;</span><br><span class="line">  private string developer;</span><br><span class="line">  private string lastReview;</span><br><span class="line">  public string message;</span><br><span class="line"></span><br><span class="line">  public DeBugInfo(int bg, string dev, string d)</span><br><span class="line">  &#123;</span><br><span class="line">      this.bugNo = bg;</span><br><span class="line">      this.developer = dev;</span><br><span class="line">      this.lastReview = d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public int BugNo</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return bugNo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string Developer</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return developer;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string LastReview</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return lastReview;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public string Message</span><br><span class="line">  &#123;</span><br><span class="line">      get</span><br><span class="line">      &#123;</span><br><span class="line">          return message;</span><br><span class="line">      &#125;</span><br><span class="line">      set</span><br><span class="line">      &#123;</span><br><span class="line">          message = value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用自定义特性"><a href="#应用自定义特性" class="headerlink" title="应用自定义特性"></a>应用自定义特性</h2><p>通过把特性放置在紧接着它的目标之前，来应用该特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[DeBugInfo(45, &quot;Zara Ali&quot;, &quot;12/8/2012&quot;, Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">[DeBugInfo(49, &quot;Nuha Ali&quot;, &quot;10/10/2012&quot;, Message = &quot;Unused variable&quot;)]</span><br><span class="line">class Rectangle</span><br><span class="line">&#123;</span><br><span class="line">  // 成员变量</span><br><span class="line">  protected double length;</span><br><span class="line">  protected double width;</span><br><span class="line">  public Rectangle(double l, double w)</span><br><span class="line">  &#123;</span><br><span class="line">      length = l;</span><br><span class="line">      width = w;</span><br><span class="line">  &#125;</span><br><span class="line">  [DeBugInfo(55, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;,</span><br><span class="line">  Message = &quot;Return type mismatch&quot;)]</span><br><span class="line">  public double GetArea()</span><br><span class="line">  &#123;</span><br><span class="line">      return length * width;</span><br><span class="line">  &#125;</span><br><span class="line">  [DeBugInfo(56, &quot;Zara Ali&quot;, &quot;19/10/2012&quot;)]</span><br><span class="line">  public void Display()</span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(&quot;Length: &#123;0&#125;&quot;, length);</span><br><span class="line">      Console.WriteLine(&quot;Width: &#123;0&#125;&quot;, width);</span><br><span class="line">      Console.WriteLine(&quot;Area: &#123;0&#125;&quot;, GetArea());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;特性（Attribute）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。&lt;/p&gt;
&lt;p&gt;.Net 框架提供了两种类型的
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="c#" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>牧云集-1</title>
    <link href="http://yoursite.com/2019/02/21/%E7%89%A7%E4%BA%91%E9%9B%86-1/"/>
    <id>http://yoursite.com/2019/02/21/牧云集-1/</id>
    <published>2019-02-21T05:23:44.966Z</published>
    <updated>2019-02-21T05:29:57.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>故事1</p></blockquote><p>新郎，特地和司仪要了话筒，说了一段话，他说他父母婚姻不幸，心里那个自己，从来没有长大过。</p><p>从来我不是不爱你，不是一次次想要推开你。不是心有不忿意难平。这世间，离别太多。 太美好的你，怕握不住。</p><p>嗯，那个戒指，他配了项链挂在胸口。忽然明白，为什么十年，依旧是他们两个。</p><p>或许女孩子从来不卑微，她知道命中注定就是他。</p><p>嗯，我一直看见的婚礼都是新娘哭，新郎笑。</p><p>今天第一次看见新郎哭得双肩耸动，新娘笑着安慰，帮他抹泪。</p><p>很甜！</p><blockquote><p>故事二                                                           </p></blockquote><p>高中时一个同学沉迷网络</p><p>时常半夜翻墙出校上网</p><p>一日他照例翻墙</p><p>翻到一半就拔足狂奔而归</p><p>面色古怪，问之不语</p><p>从此认真读书，不再上网</p><p>学校盛传他见鬼了</p><p>后来他考上名校，我们问起这事</p><p>他沉默良久，说</p><p>“那天父亲来送生活费</p><p>舍不得住旅馆，在墙下坐了一夜”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;故事1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新郎，特地和司仪要了话筒，说了一段话，他说他父母婚姻不幸，心里那个自己，从来没有长大过。&lt;/p&gt;
&lt;p&gt;从来我不是不爱你，不是一次次想要推开你。不是心有不忿意难平。这世间，离别太多。 太美好的你，怕
      
    
    </summary>
    
      <category term="洛书" scheme="http://yoursite.com/categories/%E6%B4%9B%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Python-1</title>
    <link href="http://yoursite.com/2019/02/16/python1/"/>
    <id>http://yoursite.com/2019/02/16/python1/</id>
    <published>2019-02-15T23:29:13.542Z</published>
    <updated>2019-02-21T13:43:34.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(&apos;please enter your name: &apos;)</span><br><span class="line">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><ol><li><p>Python允许用r’’表示’’内部的字符串默认不转义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure></li><li><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容, <em><code>...</code>是提示符，不是代码的一部分</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(r&apos;&apos;&apos;hello,</span><br><span class="line">world&apos;&apos;&apos;)</span><br></pre></td></tr></table></figure></li><li><p>一个布尔值只有True、False两种值,布尔值可以用and、or和not运算。  </p></li><li><p>用全部大写的变量名表示常量只是一个习惯上的用法 , eg: PI</p></li><li><p>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure></li></ol><p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><ol start="6"><li>Python的整数没有大小限制，Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</li></ol><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul><li>美国ASCII编码</li><li>中国GB2312编码</li><li>Unicode统一编码 -&gt; UTF-8编码(可变长编码)</li></ul><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001387245992536e2ba28125cf04f5c8985dbc94a02245e000/0" alt=""></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001387245979827634fd6204f9346a1ae6358d9ed051666000/0" alt=""></p><h2 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h2><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure></p><p>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。</p><p>Python对bytes类型的数据用带b前缀的单引号或双引号表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = b&apos;ABC&apos;</span><br></pre></td></tr></table></figure></p><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128)</span><br></pre></td></tr></table></figure></p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure></p><p>如果bytes中包含无法解码的字节，decode()方法会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeDecodeError: &apos;utf-8&apos; codec can&apos;t decode byte 0xff in position 3: invalid start byte</span><br></pre></td></tr></table></figure></p><p>如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;)</span><br><span class="line">&apos;中&apos;</span><br></pre></td></tr></table></figure></p><p>要计算str包含多少个字符，可以用len()函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b&apos;ABC&apos;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;</span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)</span><br><span class="line">&apos;Hi, Michael, you have $1000000.&apos;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>占位符</th><th style="text-align:left">替换内容</th></tr></thead><tbody><tr><td>%d</td><td style="text-align:left">整数</td></tr><tr><td>%f</td><td style="text-align:left">浮点数</td></tr><tr><td>%s</td><td style="text-align:left">字符串</td></tr><tr><td>%x</td><td style="text-align:left">十六进制整数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;输入与输出&quot;&gt;&lt;a href=&quot;#输入与输出&quot; class=&quot;headerlink&quot; title=&quot;输入与输出&quot;&gt;&lt;/a&gt;输入与输出&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>pycharm-basics</title>
    <link href="http://yoursite.com/2019/02/16/pycharm/"/>
    <id>http://yoursite.com/2019/02/16/pycharm/</id>
    <published>2019-02-15T22:53:26.631Z</published>
    <updated>2019-02-23T11:58:08.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的默认快捷键："><a href="#常用的默认快捷键：" class="headerlink" title="常用的默认快捷键："></a>常用的默认快捷键：</h1><p><img src="https://pic3.zhimg.com/80/v2-2c95f7f722a4342d1db875c03ef45daa_hd.jpg" alt=""></p><h1 id="调试栏的几个重要的按钮作用："><a href="#调试栏的几个重要的按钮作用：" class="headerlink" title="调试栏的几个重要的按钮作用："></a>调试栏的几个重要的按钮作用：</h1><p><img src="https://pic4.zhimg.com/80/v2-0353997a0ba329f1211451ef5028ed13_hd.jpg" alt=""></p><p>Resume Program：断点调试后，点击按钮，继续执行程序；</p><p><img src="https://pic4.zhimg.com/80/v2-a8c0d6061d0a68efaf22f680c18385fb_hd.jpg" alt=""></p><p>Step Over ：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和Step Into效果一样的（简而言之，越过子函数，但子函数会执行）；</p><p><img src="https://pic3.zhimg.com/80/v2-7cda50d4e2f7db7b2754f02a2344e432_hd.jpg" alt=""></p><p>Step Into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；</p><p><img src="https://pic2.zhimg.com/80/v2-82ce1dc84514744a8fd46b9226454655_hd.jpg" alt=""></p><p>Step Out ： 当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Python报错TypeError: ‘&lt;’ not supported between instances of ‘str’ and ‘int’<br>input()返回的数据类型是str，不能直接和整数进行比较，必须先把str换成整数，使用int()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 n = int(input(&quot;Input a number:&quot;))</span><br><span class="line">2 if n&gt;=100:print(int(n)/10)</span><br><span class="line">3 else:print(int(n)*10)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用的默认快捷键：&quot;&gt;&lt;a href=&quot;#常用的默认快捷键：&quot; class=&quot;headerlink&quot; title=&quot;常用的默认快捷键：&quot;&gt;&lt;/a&gt;常用的默认快捷键：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-2c9
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统操作与磁盘管理</title>
    <link href="http://yoursite.com/2019/02/16/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/16/linux文件系统操作与磁盘管理/</id>
    <published>2019-02-15T16:42:03.451Z</published>
    <updated>2019-02-17T03:57:40.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看磁盘和目录的容量"><a href="#查看磁盘和目录的容量" class="headerlink" title="查看磁盘和目录的容量"></a>查看磁盘和目录的容量</h1><blockquote><p>使用df命令查看磁盘的容量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ df</span><br><span class="line">$ df -h</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>使用du命令查看目录的容量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 默认同样以 块 的大小展示</span><br><span class="line">$ du</span><br><span class="line"># 加上-h参数，以更易读的方式展示</span><br><span class="line">$ du -h</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数指定查看目录的深度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 只查看1级目录的信息</span><br><span class="line">$ du -h -d 0 ~</span><br><span class="line"># 查看2级</span><br><span class="line">$ du -h -d 1 ~</span><br></pre></td></tr></table></figure></p><p>常用参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。</span><br><span class="line">du -a #同--all 显示目录中所有文件的大小。</span><br><span class="line">du -s #同--summarize 仅显示总计，只列出最后加总的值。</span><br></pre></td></tr></table></figure></p><h1 id="创建虚拟磁盘"><a href="#创建虚拟磁盘" class="headerlink" title="创建虚拟磁盘"></a>创建虚拟磁盘</h1><blockquote><p>用dd命令从标准输入读入用户的输入到标准输出或者一个文件中：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 输出到文件</span><br><span class="line">$ dd of=test bs=10 count=1</span><br><span class="line"># 输出到标准输出</span><br><span class="line">$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1</span><br><span class="line"># 注:在打完了这个命令后，继续在终端打字，作为你的输入</span><br></pre></td></tr></table></figure><ul><li>bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如’K’，’M’，’G’等单位），count用于指定块数量。</li></ul><blockquote><p>将输出的英文字符转换为大写再写入文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用-dd-命令创建虚拟镜像文件"><a href="#使用-dd-命令创建虚拟镜像文件" class="headerlink" title="使用 dd 命令创建虚拟镜像文件"></a>使用 dd 命令创建虚拟镜像文件</h2><blockquote><p>从/dev/zero设备创建一个容量为 256M 的空文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/zero of=virtual.img bs=1M count=256</span><br><span class="line">$ du -h virtual.img</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"><a href="#使用-mkfs-命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）" class="headerlink" title="使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）"></a>使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）</h2><blockquote><p>$ sudo mkfs.ext4 virtual.img</p></blockquote><h2 id="使用-mount-命令挂载磁盘到目录树"><a href="#使用-mount-命令挂载磁盘到目录树" class="headerlink" title="使用 mount 命令挂载磁盘到目录树"></a>使用 mount 命令挂载磁盘到目录树</h2><ul><li><p>mount命令的一般格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [options] [source] [directory]</span><br></pre></td></tr></table></figure></li><li><p>一些常用操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查看磁盘和目录的容量&quot;&gt;&lt;a href=&quot;#查看磁盘和目录的容量&quot; class=&quot;headerlink&quot; title=&quot;查看磁盘和目录的容量&quot;&gt;&lt;/a&gt;查看磁盘和目录的容量&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用df命令查看磁盘的容量&lt;br&gt;&lt;figure 
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-basics</title>
    <link href="http://yoursite.com/2019/02/16/linux/"/>
    <id>http://yoursite.com/2019/02/16/linux/</id>
    <published>2019-02-15T16:38:14.061Z</published>
    <updated>2019-03-08T14:07:21.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux的几个优点："><a href="#Linux的几个优点：" class="headerlink" title="Linux的几个优点："></a>Linux的几个优点：</h2><ol><li>免费</li><li>很多软件原生是在Linux下运行的，庞大的社区支持，生态环境好。</li><li>开源，可被定制，开放，多用户的网络操作系统。</li><li>相对安全稳定</li></ol><h2 id="Linux-基本目录结构"><a href="#Linux-基本目录结构" class="headerlink" title="Linux 基本目录结构"></a>Linux 基本目录结构</h2><ul><li>bin 存放二进制可执行文件(ls,cat,mkdir等) </li><li>boot 存放用于系统引导时使用的各种文件 </li><li>dev 用于存放设备文件 </li><li>etc 存放系统配置文件 </li><li>home 存放所有用户文件的根目录 </li><li>lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 </li><li>mnt 系统管理员安装临时文件系统的安装点 </li><li>opt 额外安装的可选应用程序包所放置的位置 </li><li>proc 虚拟文件系统，存放当前内存的映射 </li><li>root 超级用户目录 </li><li>sbin 存放二进制可执行文件，只有root才能访问 </li><li>tmp 用于存放各种临时文件 </li><li>usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 </li><li>var 用于存放运行时需要改变数据的文件</li></ul><blockquote><p>作者：Java3y<br>链接：<a href="https://www.jianshu.com/p/a182a0be4b8a" target="_blank" rel="noopener">https://www.jianshu.com/p/a182a0be4b8a</a></p></blockquote><h2 id="关于linux的不错的文章"><a href="#关于linux的不错的文章" class="headerlink" title="关于linux的不错的文章"></a>关于linux的不错的文章</h2><ol><li><a href="https://www.vincentqin.tech/posts/Linux-commands/" target="_blank" rel="noopener">Linux指令学习笔记</a></li><li><a href="https://www.cnblogs.com/sxdcgaq8080/p/7498906.html" target="_blank" rel="noopener">目录文件权限的查看和修改</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux的几个优点：&quot;&gt;&lt;a href=&quot;#Linux的几个优点：&quot; class=&quot;headerlink&quot; title=&quot;Linux的几个优点：&quot;&gt;&lt;/a&gt;Linux的几个优点：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;免费&lt;/li&gt;
&lt;li&gt;很多软件原生是在Linux下运行
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux压缩解压工具</title>
    <link href="http://yoursite.com/2019/02/15/linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    <id>http://yoursite.com/2019/02/15/linux压缩解压/</id>
    <published>2019-02-14T16:48:41.114Z</published>
    <updated>2019-02-15T04:18:33.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h1><p>linux常见格式：<code>.zip</code>,<code>.rar</code>,<code>.7z</code>,<code>.tar</code>,<code>.gz</code>,<code>.xz</code>,<code>.bz2</code>,<code>.tar.gz</code>,<code>.tar.xz</code>,<code>tar.bz2</code>,<code>.tar.7z</code></p><h2 id="zip压缩打包程序"><a href="#zip压缩打包程序" class="headerlink" title="zip压缩打包程序"></a>zip压缩打包程序</h2><h3 id="使用zip打包文件夹"><a href="#使用zip打包文件夹" class="headerlink" title="使用zip打包文件夹"></a>使用zip打包文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/shiyanlou</span><br><span class="line">$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop</span><br><span class="line">$ du -h shiyanlou.zip</span><br><span class="line">$ file shiyanlou.zip</span><br></pre></td></tr></table></figure><ul><li>-r 参数表示递归打包包含子目录的全部内容，</li><li>-q 参数表示为安静模式，即不向屏幕输出信息，</li><li>-o，表示输出文件，需在其后紧跟打包输出文件名。</li><li>du ,命令查看打包后文件的大小</li></ul><h3 id="设置压缩级别为9和1（9最大，1最小），重新打包："><a href="#设置压缩级别为9和1（9最大，1最小），重新打包：" class="headerlink" title="设置压缩级别为9和1（9最大，1最小），重新打包："></a>设置压缩级别为9和1（9最大，1最小），重新打包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br><span class="line">$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br></pre></td></tr></table></figure><ul><li>-[1-9] 表示压缩级别，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。</li><li>-x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，<strong>注意：这里只能使用绝对路径，否则不起作用。</strong></li></ul><h3 id="创建加密-zip-包"><a href="#创建加密-zip-包" class="headerlink" title="创建加密 zip 包"></a>创建加密 zip 包</h3><p>使用 -e 参数可以创建加密压缩包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure></p><p><strong>如果你想让你在 Linux 创建的 zip 压缩文件在 Windows 上解压后没有任何问题,需要加上 <code>-l</code>参数将<code>LF</code> 转换为 <code>CR+LF</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure></p><h2 id="使用-unzip-命令解压缩-zip-文件"><a href="#使用-unzip-命令解压缩-zip-文件" class="headerlink" title="使用 unzip 命令解压缩 zip 文件"></a>使用 unzip 命令解压缩 zip 文件</h2><p>将 shiyanlou.zip 解压到当前目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip shiyanlou.zip</span><br></pre></td></tr></table></figure></p><p>使用安静模式，将文件解压到指定目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -q shiyanlou.zip -d ziptest</span><br></pre></td></tr></table></figure></p><p>如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -l shiyanlou.zip</span><br></pre></td></tr></table></figure></p><p><strong>通常 Windows 系统上面创建的中文名压缩文件，默认会采用 GBK 编码，而 Linux 上面默认使用的是 UTF-8 编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -O GBK 中文压缩文件.zip</span><br></pre></td></tr></table></figure></p><h2 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h2><blockquote><p>创建一个 tar 包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /home/shiyanlou</span><br><span class="line">$ tar -cf shiyanlou.tar /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>-c 表示创建一个 tar 包文件</li><li>-f 用于指定创建的文件名</li><li>-v 以可视的的方式输出打包的文件</li></ul><blockquote><p>解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir tardir</span><br><span class="line">$ tar -xf shiyanlou.tar -C tardir</span><br></pre></td></tr></table></figure><blockquote><p>只查看不解包文件 -t 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -tf shiyanlou.tar</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure><blockquote><p>解压 *.tar.gz 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>zip：</p><pre><code>打包 ：zip something.zip something （目录请加 -r 参数）解包：unzip something.zip指定路径：-d 参数</code></pre><p>tar：</p><pre><code>打包：tar -cf something.tar something解包：tar -xf something.tar指定路径：-C 参数</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;压缩文件&quot;&gt;&lt;a href=&quot;#压缩文件&quot; class=&quot;headerlink&quot; title=&quot;压缩文件&quot;&gt;&lt;/a&gt;压缩文件&lt;/h1&gt;&lt;p&gt;linux常见格式：&lt;code&gt;.zip&lt;/code&gt;,&lt;code&gt;.rar&lt;/code&gt;,&lt;code&gt;.7z&lt;/code&gt;
      
    
    </summary>
    
      <category term="河图" scheme="http://yoursite.com/categories/%E6%B2%B3%E5%9B%BE/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
</feed>
